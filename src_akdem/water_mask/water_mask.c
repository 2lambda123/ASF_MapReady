/****************************************************************************** 
NAME:  
	water_mask.c 

SYNOPSIS:
    
DESCRIPTION:
           Calculates the overlap between two level zero swath files. 

EXTERNAL ASSOCIATES:
    NAME:  USAGE:
    -----------------------------------------------------------------
    
FILE REFERENCES:
    NAME:  USAGE:
    -----------------------------------------------------------------
    dem_file	DEM of area that the swaths cover for masking the water.
    bound_file	file generated by swath_offset(1).

PROGRAM HISTORY:
    VERS:  DATE:  AUTHOR:
    -----------------------------------------------------------------
     1.0   7/00   D.Koster   Initial Development.
     1.01  7/01   R. Gens    Added logfile and quiet switch
     1.2   3/02   P. Denny   Updated commandline parsing & usage()

HARDWARE/SOFTWARE LIMITATIONS: ALGORITHM

DESCRIPTION:
	This program takes a DEM, and the par files of two images that are being used
as an interferometric pair.  After being cut down to the area of coincedence with 
swath_offset(1), this program further refines start and end lines to coincedent area
over land.  This is done by checking the location blocks in the par files against the
provided DEM.

ALGORITHM REFERENCES:
        
BUGS:

*****************************************************************************/
#include "swath_bound.h"
#include "asf.h"
#include "asf_meta.h"
#include "asf_las.h"
#include "ddr.h"
#include "dateUtil.h"
#include "cproj.h"
#include "proj.h"

#define VERSION 1.2


/* Prototypes */
double get_line(int blockNr, char *parFile, char *metaFile);
int index_dem(char *demName, long maxSample, long line, long sample);
void get_demxy(struct DDR dem_ddr, forward_transform *latLon2proj, float lat, float lon, 
               double *dem_x, double *dem_y);
int where_is_land(char *demName, float *flat, float *flon, float *llat, float *llon,
                  float percent, int fromBlock, int toBlock, int dir);
void usage(char *name);


int main(int argc, char *argv[])
{
	FILE *fptr;
	struct swathbounds sB;

	char demName[255];
	char boundsName[255];
	char parFile[255], metaFile[255];
	char param[255], line[255];	
	double oldLine, newLine, deltaLine;

	float *fLat1, *fLon1, *lLat1, *lLon1;
	float percent=1.0;
	int startBlock, endBlock, ii;
	int tempBlock;

	logflag=quietflag=0;
	currArg=1;            /* from cla.h which is in asf.h */

/* Parse command line args */
	while (currArg < (argc-2))
	{
		char *key=argv[currArg++];
		if (strmatch(key,"-r")) {
			CHECK_ARG(1) /*one floating point argument: land percent */
			percent = atof(GET_ARG(1));
			if(percent < 0)
			  {printf("**  -r <%.3f>: Cannot go below 0.0 (0%%)\n",percent); usage(argv[0]);}
			if(percent > 1.0)
			  {printf("**  -r <%.3f>: Cannot exceed 1.0 (100%%)\n",percent); usage(argv[0]);}
		} 
		else if (strmatch(key,"-quiet")) {
			quietflag=1;
		} 
		else if (strmatch(key,"-log")) {
			CHECK_ARG(1) /*one string argument: logfile name */
			strcpy(logFile,GET_ARG(1));
			fLog = FOPEN(logFile, "a");
			logflag=1;
		}
		else {printf("\n*****Unrecognized option keyword:  %s\n\n",argv[currArg-1]);usage(argv[0]);}
	}
	if ((argc-currArg) < 2) {printf("Insufficient arguments.\n"); usage(argv[0]);}

	/* Grab the required arguments */
	strcpy(demName, argv[currArg++]);
	strcat(demName, ".img");
	strcpy(boundsName, argv[currArg]);
/* Done processing command line arguments.*/

printf("dem = %s\nbound = %s\n",demName,boundsName);
        system("date");
        printf("Program: water_mask\n\n");
	if (logflag) {
	  StartWatchLog(fLog);
          printLog("Program: water_mask\n\n");
	}
 
	/* read bound file generated by swath_offset */
	read_bound_file(boundsName, &sB);

	/* Which of the two in the pair start at the top. Use that 
	   one to determine new line offsets for areas with water */

	if(sB.par_start_loc1 < sB.par_start_loc2)
	{
		strcpy(metaFile, sB.metaFile2);
		strcpy(parFile, sB.parFile1);
/*		printf("opening %s \n", parFile);*/
		startBlock = sB.par_start_loc1;
		endBlock = sB.par_end_loc1;
	}
	else if(sB.par_start_loc2 < sB.par_start_loc1 )
	{
		strcpy(metaFile, sB.metaFile2);
		strcpy(parFile, sB.parFile2);
/*		printf("opening %s \n", parFile);*/
		startBlock = sB.par_start_loc2;
		endBlock = sB.par_end_loc2;
	}
	else 
	{
		printf("Something is wrong with the boundfile generated with\n");
		printf("swath_offset, Failed to open any par files \n");
		printf("Exiting, Error 102\n");
		exit(102);
	}
	/* allocate space for the lat/lon from the selected swath's par file*/
	fLat1 = (float *) MALLOC(sizeof(float)*(endBlock+1) );
	fLon1 = (float *) MALLOC(sizeof(float)*(endBlock+1) );
	lLat1 = (float *) MALLOC(sizeof(float)*(endBlock+1) );
	lLon1 = (float *) MALLOC(sizeof(float)*(endBlock+1) );

	fptr = FOPEN(parFile, "r");
	ii = 0;
	/* read the par file obtaining the lat/lon information for the 
	   near & far ranges */
	while(ii < endBlock && NULL != fgets(line, 255, fptr) )
	{
		sscanf(line, "%s", param);
		if(strncmp(param, "first_pixel_ll", 14) == 0)
		{
			sscanf(line, "%s %f %f", param, &fLat1[ii], &fLon1[ii]);
			fgets(line, 255, fptr);
			sscanf(line, "%s %f %f", param, &lLat1[ii], &lLon1[ii]);
			ii++;
		}
	}
	FCLOSE(fptr);

	/* now check the top of the images to see if there is water there, 
	   if there is, calculate where the land is, and set the masked_start_offsets
	   in the boundfile so that it reflects the changes.  */

/*	printf("done reading those values, now indexing into dem\n");
	printf("startBlock: %d\n endBlock: %d\n", startBlock, endBlock);*/
	tempBlock = startBlock;
/*	printf("tempBlock: %i\n", tempBlock);*/
	startBlock = where_is_land(demName, fLat1, fLon1, lLat1, lLon1, percent, 
			startBlock, endBlock, 1);
/*	printf("startBlock : %i\n", startBlock);*/

	if(tempBlock != startBlock)
	{
/*		printf("sB% i\n", startBlock);*/
		oldLine = get_line(tempBlock, parFile, metaFile); 
		newLine = get_line(startBlock, parFile, metaFile);
/*		printf("sB %i\n", startBlock);
		printf("oldLine:%i\n", oldLine);
		printf("newLine:%i\n", newLine);*/

		deltaLine = newLine-oldLine;	
		sB.masked_start_offset1 = sB.start_offset1 + (int) deltaLine;
		sB.masked_start_offset2 = sB.start_offset2 + (int) deltaLine;
	}
/*	printf("%i -> %i\n", endBlock, startBlock);*/

	/* check the bottom of the image for water, and perform the same sort of
 	   masking procedure */	
	tempBlock = endBlock;
	endBlock = where_is_land(demName, fLat1, fLon1, lLat1, lLon1, percent,
		endBlock-1, startBlock, -1);

	if(tempBlock != endBlock)
	{
		oldLine = get_line(tempBlock, parFile, metaFile);
		newLine = get_line(endBlock-1, parFile, metaFile);
		deltaLine = newLine-oldLine;
		sB.masked_end_offset1 = sB.end_offset1 + (int) deltaLine;
		sB.masked_end_offset2 = sB.end_offset2 + (int) deltaLine;
/*		printf("tempBlock: %i\n", tempBlock);
		printf("endBlock: %i\n", endBlock);*/
	}

	/* calculate the number of patches from the start of the first image to the 
	   start of the last image */
	sB.masked_patches = ((sB.masked_end_offset1-sB.masked_start_offset1-4096) /3365 ) + 1;

	/* re-write the boundfile, so that any changes are reflected. */
	make_bound_file(boundsName, sB);

	return 0;
}


/* get the start line of a block based on the par and metafiles */
double get_line(int blockNr, char *parFile, char *metaFile)
{
	ymd_date date1;
	hms_time time1;
	julian_date jDate;

	FILE *fptr;
	
	char lineDatec[255];
	char line[255], param[255];
	double lineDated=0.0;
	double azPixTime = 0.0;
	int tempBlockNr;
/*	printf("bNr: %i\n", blockNr);*/

	fptr = FOPEN(parFile, "r");
	/* Parse through .par file looking for the right location block
	   then read the line date of the location block */
	while( lineDated == 0.0 && NULL != fgets(line, 255, fptr) )
	{
		sscanf(line, "%s", param);
		if(strncmp(param, "block_nr", 8) == 0)
		{
			sscanf(line, "%s%i", param, &tempBlockNr);
			if(tempBlockNr == blockNr)
			{
				while(lineDated == 0.0 && NULL != fgets(line, 255, fptr) )
				{
					sscanf(line, "%s", param);
					if( strncmp(param, "line_date", 9) == 0)
					{
						sscanf(line, "%s%s", param, lineDatec);
						lineDated = 1.0;
					}
				}
			}
		}
	}
	lineDated = 0.0;
	FCLOSE(fptr);

	/* go through .meta file looking for the azPixTime to get the 
	   number of pixels per time for conversion */
	fptr = FOPEN(metaFile, "r");
	while(azPixTime == 0.0 && NULL != fgets(line, 255, fptr) )
	{
		sscanf(line, "%s", param);
		if(strncmp(param, "azPixTime", 9) == 0)
			sscanf(line, "%s%lf", param, &azPixTime);	
	}		
	FCLOSE(fptr);

	/* parse the given time with dateutils */
	parse_ymdTime(lineDatec, &date1, &time1);
	date_ymd2jd(&date1, &jDate);
	lineDated = date_hms2sec(&time1) + (double)(date_getMJD(&jDate) * 3600 * 24);

	return (lineDated / azPixTime);
}

/* index into provided DEM based on given line/sample coordinates */
int index_dem(char *demName, long maxSample, long line, long sample)
{
	FILE *fptr;

	long long byteIndex;
	int demValueAt;

	if (!quietflag) printf("   Checking Line: %li, Sample: %li\n", line, sample);
	byteIndex = ((maxSample*line) + sample)*2;	

	fptr = FOPEN(demName, "r");

/*	printf("   seeking %li bytes into the file\n", byteIndex);*/
	FSEEK64(fptr, byteIndex ,SEEK_SET);

	demValueAt = getc(fptr) << 8;
	demValueAt = demValueAt + getc(fptr);

	FCLOSE(fptr);
	
	return demValueAt;
}

/* get the Line sample coordinates of a lat/lon in the DEM */
void get_demxy(struct DDR dem_ddr, forward_transform *latLon2proj, float lat, float lon, 
		double *dem_x, double *dem_y)
{
	double demProj_x, demProj_y;

	latLon2proj[dem_ddr.proj_code](lon*D2R,lat*D2R,
				&demProj_x,&demProj_y);

	printf("   Lat: %lf, Lon: %lf\n", lat, lon);
	if (logflag) {
	  sprintf(logbuf,"   Lat: %lf, Lon: %lf\n", lat, lon);
	  printLog(logbuf);
	}
	*dem_x=(demProj_x-dem_ddr.upleft[1])/(dem_ddr.upright[1]
				-dem_ddr.upleft[1])*dem_ddr.ns;
	*dem_y=(demProj_y-dem_ddr.upleft[0])/(dem_ddr.loleft [0]
				-dem_ddr.upleft[0])*dem_ddr.nl;
}

/* test the line to see if it covers land, if not, go to the next, until 
   some Land is found, return the block number that contains the land. 
   if no land is found over the whole line, a percentage of the swath is 
   checked in the range, if there is land covering that percentage, 
   return the block number of that location block.  If no land is found
   with these two tests, the program returns error, assuming that all 
   or most of the swath is overwater */
int where_is_land(char *demName, float *flat, float *flon, float *llat, float *llon,
			float percent, int fromBlock, int toBlock, int dir)
{

	/* Map projection structs */
	struct DDR dem_ddr;
	forward_transform latLon2proj[100];

	/* keep track of which side is more overland */
	int first_overland = 0, second_overland = 0;

	/* x/y for first/last sample/range DEM coordinates */
	double dem_xf=-1, dem_yf=-1;
	double dem_xl=-1, dem_yl=-1;

	/* Error flags, and values used for iteration */
	int ii, xx, yy;
	int iflg=0;

	/* initialize the map projection */
	c_getddr(demName, &dem_ddr);

	for_init(dem_ddr.proj_code, dem_ddr.zone_code, dem_ddr.proj_coef, 
			dem_ddr.datum_code, NULL,NULL, &iflg, latLon2proj);
	if (iflg != 0)
	{
		sprintf(errbuf,"   ERROR: Problem in map projection initialization, this could\n \
				indicate an error in the provided DEM, exiting. \n");
		printErr(errbuf);
	}

	/* Start looking for lines that appear to be overland */
	/* This loop allows both forward & reverse iteration from 
	   the first to last location block or from the last to the 
	   first location block */
/*	printf("About to begin evaluating the lat/lon stuff\n");*/
	for(ii = fromBlock; (((ii < toBlock)&&(dir>0))||((ii > toBlock)&&(dir<0))); ii+=dir)
	{	
		get_demxy(dem_ddr, latLon2proj, flat[ii], flon[ii], &dem_xf, &dem_yf);
		get_demxy(dem_ddr, latLon2proj, llat[ii], llon[ii], &dem_xl, &dem_yl);

		/* if location not in DEM */
		if((dem_xf < 0) || (dem_yf < 0) || 
			(dem_yf > dem_ddr.nl) || (dem_xf > dem_ddr.ns) ||
			(dem_xl < 0) || (dem_yl < 0) || (dem_yl > dem_ddr.nl) ||
			(dem_xl > dem_ddr.ns)) 

		{
			printf("   Lat lon for Block %i, is either water or not in\n", ii);
			printf("   the given DEM\n");
			printf("   dem_xf: %lf, dem_yf: %lf, dem_xl: %lf, dem_yl %lf\n",
				   dem_xf, dem_yf, dem_xl, dem_yl);
			printf("   flat : %lf, flon : %lf\n", flat[ii], flon[ii]);
			printf("   llat : %lf, llon : %lf\n", llat[ii], llon[ii]);
			if (logflag) {
			  sprintf(logbuf,"   Lat lon for Block %i, is either water or not in\n", ii);
			  printLog(logbuf);
			  sprintf(logbuf,"   the given DEM\n");
			  printLog(logbuf);
			  sprintf(logbuf,"   dem_xf: %lf, dem_yf: %lf, dem_xl: %lf, dem_yl %lf\n",
			  	     dem_xf, dem_yf, dem_xl, dem_yl);
			  printLog(logbuf);
			  sprintf(logbuf,"   flat : %lf, flon : %lf\n", flat[ii], flon[ii]);
			  printLog(logbuf);
			  sprintf(logbuf,"   llat : %lf, llon : %lf\n", llat[ii], llon[ii]);
			  printLog(logbuf);
			}

			/* if either of these are over the DEM, increment
			   a counter so that if a swath follows the edge of 
			   a swath, we can try checking for water at a smaller
			   percentage of the range of the swath */
			if((dem_xf >= 0) && (dem_yf >= 0) && 
				(dem_xf < dem_ddr.nl) && (dem_yf < dem_ddr.ns))
			{ first_overland++; }
			if((dem_xl >= 0) && (dem_yl >= 0) && 
				(dem_xl < dem_ddr.nl) && (dem_yl < dem_ddr.ns))
			{ second_overland++; }
			dem_xf = -1.0;
			dem_yf = -1.0;
		}

		/* if overland */
		if((dem_xf >= 0) && (dem_yf >= 0 ) && 
			(dem_xf < dem_ddr.ns) && (dem_yf < dem_ddr.nl) &&
			(dem_xl >= 0) && (dem_yl >= 0) &&
			(dem_xl < dem_ddr.ns) && (dem_yl < dem_ddr.nl))
		{
			printf("   Lines: %lf, Samples: %lf\n", dem_yf, dem_xf);
			if (logflag) {
			  sprintf(logbuf,"   Lines: %lf, Samples: %lf\n", dem_yf, dem_xf);
			  printLog(logbuf);
			}

			/* is this overwater? */
			xx=index_dem(demName, dem_ddr.ns, dem_yf, dem_xf);
			yy=index_dem(demName, dem_ddr.ns, dem_yl, dem_xl);

			if (!quietflag) printf("   Value: %li, and %li\n", xx, yy);
			/* if not overwater, then we've found a good location block */
			if((xx > 0) && (yy > 0))
			{
				printf("   Over land at %lf, %lf\n", flat[ii], flon[ii]);
				printf("   Location block: %i\n\n", ii);
				if (logflag) {
				  sprintf(logbuf,"   Over land at %lf, %lf\n", flat[ii], flon[ii]);
				  printLog(logbuf);
				  sprintf(logbuf,"   Location block: %i\n\n", ii);
				  printLog(logbuf);
				}
				return ii; 
			}
			/* otherwise, we increment the correct value so that 
			   if no good block is found we can base a percentage 
			   of land in the range off of either near or far 
			   lat/lon */
			else if((xx > 0) && (yy <= 0))
			{
				first_overland++;
			}
			else if((xx <= 0) && (yy > 0))
			{
				second_overland++;
			}
		}
	}
	if (!quietflag) {
	  printf("    Warning: This program has found that this swath lies on a border of either \n");
	  printf("       water or the DEM, along the Azimuth.  This program will now attempt\n"); 
	  printf("       to locate a patch to begin co-registration based on the %lf%%\n", percent*100);
	  printf("       required land in range\n\n");
	} 
	/* Handles the case where no, one whole line is over land */
	if((dem_xf <= 0) || (dem_yf <= 0))
	{
		printf("   This image was not over land or not in the provided DEM\n");
		if (logflag) printLog("   This image was not over land or not in the provided DEM\n");
		if(first_overland > second_overland)
		{
			printf("   %d, blocks have near range over land.\n", first_overland);
			if (logflag) {
			  sprintf(logbuf,"   %d, blocks have near range over land.\n", first_overland);
			  printLog(logbuf);
			}

			for(ii = fromBlock; (((ii < toBlock)&&(dir>0))||((ii > toBlock)&&(dir<0))); ii+=dir)
			{
				get_demxy(dem_ddr, latLon2proj, flat[ii], flon[ii], &dem_xf, &dem_yf);
				get_demxy(dem_ddr, latLon2proj, llat[ii], 
					flon[ii]+((llon[ii]-flon[ii])*percent), &dem_xl, &dem_yl);

				if((dem_xf < 0) || (dem_yf < 0) ||
					(dem_xf > dem_ddr.nl) || (dem_yf > dem_ddr.ns)||
					(dem_xl < 0) || (dem_yl < 0) ||
					(dem_xl > dem_ddr.nl) || (dem_yl > dem_ddr.ns))
				{
					if (!quietflag) {
					  printf("Lines: %lf, Samples: %lf\n", dem_yf, dem_xf);
					  printf("Lines: %lf, Samples: %lf\n", dem_yl, dem_xl);
					}
					dem_xf = -1.0;
					dem_yf = -1.0;
				}else{
					xx=index_dem(demName, dem_ddr.ns, (int)dem_yf, (int)dem_xf);
					yy=index_dem(demName, dem_ddr.ns, (int)dem_yl, (int)dem_xl);
					if((xx > 0) && (yy > 0))
					{
/*						printf("over-land at %lf,%lf\n", flat[ii], flon[ii]);*/
						return ii;
					}
				}	
			}
		}else if(first_overland < second_overland)
		{
			printf("   %d, blocks have far range over land.\n", second_overland);
			if (logflag) {
			  sprintf(logbuf,"   %d, blocks have far range over land.\n", second_overland);
			  printLog(logbuf);
			}
			for(ii = fromBlock; (((ii < toBlock)&&(dir>0))||((ii > toBlock)&&(dir<0))); ii+=dir)
			{
				get_demxy(dem_ddr, latLon2proj, flat[ii], 
					llon[ii]-((llon[ii]-flon[ii])*percent), &dem_xf, &dem_yf);
				get_demxy(dem_ddr, latLon2proj, llat[ii], llon[ii],
					 &dem_xl, &dem_yl);

				if((dem_xf < 0) || (dem_yf < 0) ||
					(dem_xf > dem_ddr.nl) || (dem_yf > dem_ddr.ns)||
					(dem_xl < 0) || (dem_yl < 0) ||
					(dem_xl > dem_ddr.nl) || (dem_yl > dem_ddr.ns))
				{
					if (!quietflag) {
					  printf("Lines: %lf, Samples: %lf\n", dem_yf, dem_xf);
					  printf("Lines: %lf, Samples: %lf\n", dem_yl, dem_xl);
					}
					dem_xf = -1.0;
					dem_yf = -1.0;
				}else{
					xx=index_dem(demName, dem_ddr.ns, (int)dem_yf, (int)dem_xf);
					yy=index_dem(demName, dem_ddr.ns, (int)dem_yl, (int)dem_xl);
					if((xx > 0) && (yy > 0))
					{
						if (!quietflag)
						  printf("over-land at %lf,%lf\n", flat[ii], flon[ii]);
						return ii;
					}
				}	
			}
		 }
		else
		{
			printf("   ERROR: These images are either completely over water,\n    \
			       		outside of this DEM, or in an area that cannot\n    \
		       			be masked with this program!\n");
			printErr(errbuf);
		}
	}

	return -1;
}

void usage(char *name)
{
 printf("\n"
	"USAGE:\n"
	"   %s [-r <percent>] [-log <file>] [-quiet] <dem_file> <bound_file>\n",name);
 printf("\n"
	"REQUIRED ARGUMENTS:\n"
	"   <dem_file>   dem of area covered by swath\n"
	"   <bound_file> boundfile generated by swath_offset(1)\n");
 printf("\n"
	"OPTIONAL ARGUMENTS:\n"
	"   -r <percent> indicates the amount of range that\n"
	"                  must be land, default = 1.0 (100%%)\n"
	"   -log <file>  allows the output to be written to a log file\n"
	"   -quiet       suppresses the output to the essential\n");
 printf("\n"
	"DESCRIPTION:\n"
	"   This program uses a DEM, .par, and .meta files of a repeate geometry\n"
	"   swath pair.  This program can be run after swath_offset has been run\n");
 printf("\n"
	"Version %.2f, ASF ISAR TOOLS\n"
	"\n",VERSION);
 exit(1);
}


