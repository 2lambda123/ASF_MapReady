Documentation/Program Notes for create_tape
	Program and Documentation by Orion Lawlor, ASF STEP Lab, 1997.
	
OVERVIEW:
	create_tape is a C program designed to write ASF
format product tapes.  To run this program, you need a Volume
Descriptor File (VDF) and a set of ASF products to write.

	A VDF is a mixed binary-and-ASCII format file which describes,
in terms of 360-byte records, the contents of an ASF tape.  
Specifically, it gives the names of each of the data (.D) and
metadata (.L) files which are to be written to tape.  The VDF is
in a CEOS-Standard format, and is copiously documented elsewhere.

	create_product_tape uses concat_vdf (another ASF STEP Lab
utility) to paste the several VDF's which are passed to it together,
and extract from the VDF a list of files to write to tape.
It then uses the standard UNIX utility dd to copy the amalgamated VDF,
all the referenced files, and finally a Null Descriptor File (NDF)
to the tape.

USAGE:

  create_tape <output device name> <VDF file 1> [ <VDF 2> [...] ]
  
       <VDF file 1> the .VDF file, with extention, which specifies
		the files to write to tape.  The files
		listed in the VDF are read from the current directory
		and written to tape.  A file with the same base name, 
		but an extention of .NDF, must also be present in the 
		directory (this is the Null Volume File).
		
	<other VDF files> each specify a .VDF and the files it references.
		No NDF is needed.
		
	<output device name>  The destination tape device (e.g. /dev/rmt/1n)
		Note that you probably want a device name that ends in 
		"n"-- otherwise each file will overwrite the previous
		one on the tape.

  Example:
  	to write three volume descriptor files, a.vdf, b.VDF, and c.VdF; each
  	in their own directories A, B, and C; to /dev/rmt/1n, type
  	
  	create_tape  /dev/rmt/1n   A/a.vdf   B/b.VDF   C/c.VdF
  	
  	
SPECIAL CASES:
	A nice feature is that if you specify /dev/null as the 
	output device, the program will detect this and perform a
	"dry run"-- it will do everything it normally does except 
	actually perform the dd calls.  This is quite nice if
	you want to make sure you have all the specified files 
	before copying hundreds of megabytes of data to the tape.

	The program should work (but hasn't been tested) with
	multiple-volume VDFs and tapes-- each run of the program
	will write one complete tape.  This is NOT the same
	as multiple VDFs-- using multiple VDFs definetly works.
	

ERROR HANDLING:
	The program attempts to trap as many errors as possible,
	as early as possible-- nonexistant files, device I/O errors,
	and bad parameters are all checked and reported to the user.
	Missing files are reported BEFORE any data hits tape.
	
EXAMPLE RUN:

sparc1k: csh> ls -R blarg
blarg:
02  12  24

blarg/02:
10087002.NDF        R105104626G1S012.L  R105104632G1S014.D  R105104635G1S015.L
10087002.VDF        R105104629G1S013.D  R105104632G1S014.L  R105104638G1S016.D
R105104626G1S012.D  R105104629G1S013.L  R105104635G1S015.D  R105104638G1S016.L

blarg/12:
10087012.VDF        R105104644G1S018.L  R105104650G1S020.L  R105105617G1S002.L
R105104641G1S017.D  R105104647G1S019.D  R105104653G1S021.D
R105104641G1S017.L  R105104647G1S019.L  R105104653G1S021.L
R105104644G1S018.D  R105104650G1S020.D  R105105617G1S002.D

blarg/24:
10087024.NDF        R105105623G1S004.D  R105105629G1S006.D  R105105635G1S008.D
10087024.VDF        R105105623G1S004.L  R105105629G1S006.L  R105105635G1S008.L
R105105620G1S003.D  R105105626G1S005.D  R105105632G1S007.D
R105105620G1S003.L  R105105626G1S005.L  R105105632G1S007.L

sparc1k: csh> create_tape /dev/rmt/7n blarg/02/10087002.VDF \
blarg/12/10087012.VDF blarg/24/10087024.VDF

concat_vdf temp.VDF blarg/02/10087002.VDF blarg/12/10087012.VDF blarg/24/10087024.VDF  > vdfcatOutfile
mt -f /dev/rmt/7n rewind
dd if=temp.VDF of=/dev/rmt/7n bs=360
52+0 records in
52+0 records out
dd if=blarg/02/R105104626G1S012.L of=/dev/rmt/7n bs=5120
5+1 records in
5+1 records out
dd if=blarg/02/R105104626G1S012.D of=/dev/rmt/7n bs=8384
8193+0 records in
8193+0 records out
... (More files from blarg/02 get dumped to tape) ...
dd if=blarg/02/R105104638G1S016.L of=/dev/rmt/7n bs=5120
5+1 records in
5+1 records out
dd if=blarg/02/R105104638G1S016.D of=/dev/rmt/7n bs=8384
8193+0 records in
8193+0 records out
dd if=blarg/12/R105104641G1S017.L of=/dev/rmt/7n bs=5120
5+1 records in
5+1 records out
dd if=blarg/12/R105104641G1S017.D of=/dev/rmt/7n bs=8384
8193+0 records in
8193+0 records out
...
dd if=blarg/12/R105104653G1S021.L of=/dev/rmt/7n bs=5120
5+1 records in
5+1 records out
dd if=blarg/12/R105104653G1S021.D of=/dev/rmt/7n bs=8384
8193+0 records in
8193+0 records out
dd if=blarg/12/R105105617G1S002.L of=/dev/rmt/7n bs=5120
5+1 records in
5+1 records out
dd if=blarg/12/R105105617G1S002.D of=/dev/rmt/7n bs=8384
8193+0 records in
8193+0 records out
dd if=blarg/24/R105105620G1S003.L of=/dev/rmt/7n bs=5120
5+1 records in
5+1 records out
dd if=blarg/24/R105105620G1S003.D of=/dev/rmt/7n bs=8384
8193+0 records in
8193+0 records out
...
dd if=blarg/24/R105105635G1S008.L of=/dev/rmt/7n bs=5120
5+1 records in
5+1 records out
dd if=blarg/24/R105105635G1S008.D of=/dev/rmt/7n bs=8384
8193+0 records in
8193+0 records out
dd if=blarg/02/10087002.NDF of=/dev/rmt/7n bs=360
1+0 records in
1+0 records out
mt -f /dev/rmt/7n rewind
sparc1k: csh>

