static char sccsid_weight_c[] =
    "@(#)weight.c	1.2 96/04/09 19:13:36";

#include <stdio.h>
#include <math.h>
/* done by quyen dinh nguyen
 * 1/2/90 
 */



/* ant_wgt( forfftsize, nw, prf, fzero2nul, Inv_ant) -------

  This routine will generate the inverse azimuth antenna pattern
   for ERS-1.

 INPUT:
   forfftsize    int*4    the forward fft size.
 
   nw            int*4    the number of points within pbw.

   prf           float    the Pulse repitition frequency (Hz).

   fzero2nul     float    The frequency from zero to the null of the sinc
                          function. This value is calculated by :
                             fzero2nul = 2.0*vel/L
                          where vel and L are the azimuth velocity and
                          the physical length of the antenna. (Hz).
  
 OUTPUT:
  Inv_ant   vector of float    the inverse of the Antenna. This vector
                               is generated by:
                                  Inv_ant = 1.0/(sinc(x))**2
                               where x = pi*f/(2.0*vel/L) and f is
                               from -pbw/2.0 to pbw/2.0

*/

ant_wgt( forfftsize, nw, prf, fzero2nul, Inv_ant)
int  forfftsize,nw;
float  prf,fzero2nul,Inv_ant[1];
{
  double PI,x;
  float  xvalue,delf;
  int    i;
  PI = 4.0*atan(1.0);
  delf = prf/((float)(forfftsize));
  for(i= -nw/2; i<= nw/2; i++){
     x = PI*((double)(delf*((float)(i))/fzero2nul));
     xvalue = (x == 0.0 )? 1.0 : (float)(sin(x)/x) ;
     Inv_ant[i+nw/2] = (float)(1.0/(xvalue*xvalue));
  }

}


/*  Cos_wgt( nw, h, Cos_squared) -------------------

  This routine will generate the cos^2 weighting function in the
   azimuth dimension for ERS-1.

 INPUT:
   nw            int*4    the number of points within pbw.

   h             float*4  the pedestal level. For ERS-1, in the
                          azimuth weighting, h will be 0.3

 OUTPUT:
   Cos_squared   vector of float  the weighting function is generated by:
                                Cos_squared= h + (1-h)*cos(f)^2
                              where h is pedestal value and f is
                              calculated as:
                                f = PI*i/nw 
                              where i is in the range of -nw/2 and nw/2

*/

Cos_wgt( nw, h, Cos_squared)
int  nw;
float   h, Cos_squared[1];
{
   int i,nw2;
   float h1,xvalue;
   double x,PI;
   PI = 4.0*atan(1.0);
   h1 = 1.0-h;
   nw2 = nw/2;
   for(i=0; i<nw; i++){
       x = PI*(double)(i-nw2)/(double)(nw);
       xvalue = (float)(cos(x));
       Cos_squared[i] = h + h1*xvalue*xvalue;
   }

} 
