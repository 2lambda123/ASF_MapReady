C--  Copyright (c)1996, California Institute of Technology.
C--  U.S. Government Sponsorship acknowledged.
C-- ==========================================================================
C--
C--  Fortran Filename:	rgetx.for
C--
C--  Description:	
C--	
C--  Notes:
C--
C-- ==========================================================================

***********************************************************************
*  Name:	RGETX   
*  Module Type: LOGICAL FUNCTION 	Language: FORTRAN
*  Purpose:	REPLICATE EPHEMERIS DATA FOR COVERAGE
*  Functions called:
*  VECTOR LIBRARY:  
*  Input Parameters:
*  Name         Type    Definition
*  STARTOVER INT        if = 1, then rewind to the start of the file.
*  EUNIT	INTEGER	unit number of ephemeris file.
*  TIME1	REAL*8	START TIME OF INPUT FILE 
*  TFIRST	REAL*8	START TIME OF DESIRED STATE VECTOR.
*  TLAST	REAL*8	END TIME OF DESIRED STATE VECTOR.
*  TNODE	REAL*8	NODAL PERIOD FOR THE SATELLITE.  
*  Output Parameters:
*  Name         Type    Definition
*  x12(12)	REAL*8	STATE VECTOR FROM THE EPHEMERIS FILE
*  nodeflag	CH*1	NODE FLAG.
*  RGETX	LOGIC	.TRUE. IF FINISHED
*  			.FALSE. IF NOT FINISHED
*  Variables:
*  Locals :
*  Externals :
*  Modification History:                                            
*  Date         Author  Summary
*  11/17/95     QS      Change include file path to include/local
* 
*  Date			Revision	Author
*  $Date$ $Revision$ $Author$
*********************************************************************/
      LOGICAL FUNCTION RGetx(STARTOVER, 
     ?             EUNIT,TIME1,TFIRST,TLAST,TNODE,x12,nodeflag)
      character*100 SccsFileID
     -/'@(#)rgetx.for	5.1 98/01/08 APS/ASF\0'/

      IMPLICIT NONE
      REAL*8 TIME1, TFIRST, TLAST, TNODE, x12(12)
      CHARACTER*1 nodeflag
	  INTEGER EUNIT, STARTOVER
c---
c--port       REAL*8 G_FLT(12)
      REAL*8 X(3), V(3), T, XR, XLASC, XLAT, XLON, GHA, XDUM
      INTEGER J, IDAYS, ISECS, IMILLI
      REAL*8 X1(3), V1(3), DT, XROT, DL, DGHA, XREVS, TSECS, TMILLI
      INTEGER IFIRST
      REAL*8 TREC, XR1, XLAT1, VZ1, TREC1, TRECN, TRECN90
	  INTEGER PRINTFLAG
c---	SAVE ALL ALLOWABLE VARIABLES BETWEEN CALLS:  (REDUNDANT FOR VAX FORT)
      SAVE
c---
      INCLUDE 'APS_HOME:include/local/mps_const_earth.inc'
	  DATA IFIRST /1/
	  DATA PRINTFLAG /0/

	  IF(STARTOVER .EQ. 1) IFIRST = 1
C---	IF THIS IS NOT THE FIRST TIME THROUGH, THEN READ THE NEXT RECORD.
      IF(IFIRST .NE. 1) GO TO 2000
C---	FIRST TIME THROUGH ONLY
      IF(PRINTFLAG .EQ. 1)
     ?   WRITE(*,*) ' RGETX START:'
      IF(PRINTFLAG .EQ. 1)
     ?   WRITE(*,*)' RGETX:  TIME1 = ', TIME1
      IF(PRINTFLAG .EQ. 1)
     ?   WRITE(*,*)' RGETX:  TFIRST = ', TFIRST
      IF(PRINTFLAG .EQ. 1)
     ?   WRITE(*,*)' RGETX:  TLAST = ', TLAST
      IF(PRINTFLAG .EQ. 1)
     ?   WRITE(*,*)' RGETX:  TNODE = ', TNODE
C---	COMPUTE THE REV FOR TFIRST.  
      XREVS = (TFIRST - TIME1)/TNODE 
	  IF(XREVS .LT. 0) XREVS = 0
      IF(PRINTFLAG .EQ. 1)
     ?   WRITE(*,*)' RGETX:  XREVS = ', XREVS
      J = XREVS - 1
      J = J - 1
      IF(PRINTFLAG .EQ. 1)
     ?   WRITE(*,*)' RGETX:  J = ', J
      IF(J .LT. -1) J = -1
      IF(PRINTFLAG .EQ. 1)
     ?   WRITE(*,*)' RGETX:  J = ', J
 1000 CONTINUE
      J = J + 1
C---	POSITION TO START OF THE FILE.  
c--port--  unit EUNIT was opened in the main routine.  
      REWIND (EUNIT)
      READ(EUNIT)XDUM
C---	SET UP THE INCREMENTS BETWEEN THE FILE AND THE OUTPUT FOR THIS REV.
C---	(FIRST TIME THROUGH, THE INCREMENTS ARE ACCORDING TO THE NUMBER OF REVS
C---	BETWEEN TIME1 AND TFIRST.  )
C---	TIME (DAYS)
C---	NODE THAT WE WANT TO ROUND OFF THE DT TO THE NEAREST MILLISECOND.  
C---	SO WE ADD 1/2 A MILLISEC TO THE DT, THEN TRUNCATE TO GET THE INTEGER 
C---	DAYS, SECS, AND MILLIES, THEN RECOMPUTE THE DT BASED ON THOSE INTEGERS.
      DT = J * TNODE    + (0.5D0 / 86400 000)
C-----      WRITE (*,*) ' DT + 1/2 MILLI = ', DT
      IDAYS = DT
      TSECS =   ( (DT-IDAYS) * 86400)
      ISECS = TSECS
      TMILLI = ((TSECS - ISECS) * 1000) 
      IMILLI = TMILLI
C-----      WRITE (*,*)' IDAYS, ISECS, IMILLI = ',IDAYS,' ',ISECS,' ',IMILLI
      DT = IDAYS + ((ISECS/86400.0D0) + (IMILLI/86400 000.0D0))
C-----      WRITE(*,*)' RGETX:  DT = ', DT
C---	ROTATION (DEGREES) OF VECTORS IN INERTIAL SYSTEMS: ONE CYCLE PER YEAR
C---	IN A FORWARD DIRECTION.  REPRESENTS THE ORBIT PRECESSING IN A 
C---	SUN-SYNCHRONOUS MANNER.
      XROT = (DT / EYEAR) * 360.0D0
      XROT = MOD(XROT,360.0D0)
C---	REVS = J
C---	SUBSAT LONGITUDE:  WESTWARD DRIFT. 
C---	DT IS GIVEN IN DAYS.  DRIFT PER NODAL PERIOD IS FRACTION OF DAY*360.
      DL = DT*360.0D0
C---	GREENWICH HOUR ANGLE:  DT * RATE OF EARTH ROTATION (DEG/DAY)
      DGHA = DT * EROTI * 360.0D0
      DGHA = MOD(DGHA,360.0D0)
 2000 CONTINUE
c--port--      READ(80,END=1000)nodeflag, G_FLT
C---	TRANSFORM FROM G_FLOATING TO D_FLOATING.  (SEE 10.5.3.1 VAX FORTRAN 
C---	USER MANUAL.)
c--port--      CALL MTH$CVT_GA_DA(G_FLT(1), X(1), 3)
c--port--      CALL MTH$CVT_GA_DA(G_FLT(4), V(1), 3)
c--port--      CALL MTH$CVT_GA_DA(G_FLT(7), TREC, 1)
c--port--      CALL MTH$CVT_GA_DA(G_FLT(8), XR,   1)
c--port--      CALL MTH$CVT_GA_DA(G_FLT(9), XLASC,1)
c--port--      CALL MTH$CVT_GA_DA(G_FLT(10),XLAT, 1)
c--port--      CALL MTH$CVT_GA_DA(G_FLT(11),XLON, 1)
c--port--      CALL MTH$CVT_GA_DA(G_FLT(12),GHA,  1)
c---	no need to transform, these math variables are in in Sun float*8.  
      READ(EUNIT,END=1000)nodeflag, X, V, TREC, XR, XLASC, 
     ?                                          XLAT, XLON, GHA 
      IF(nodeflag .EQ. '_') nodeflag = '-'
      IF(IFIRST .NE. 1) GO TO 3000
C---	FIRST TIME THROUGH IN THIS RUN.  
C---	SET UP LIMITS TO PREVENT THE WRITING OF RECORDS WHICH WILL NOT MESH 
C---	WITH THE RECORDS WRITTEN IN THE NEXT READ OF THE FILE.  
C
C---	FOR EXAMPLE, SUPPOSE THE RUN OF ASAP WAS GIVEN A STATE VECTOR AT 
C---	THE ASCENDING NODE WITH A SEMIMAJOR AXIS THAT WAS A BIT SHORT.  THIS 
C---	WOULD RESULT IN A NODAL PERIOD LESS THAN THE DESIRED NODAL PERIOD.  
C---	THE DANGER IS THAT THERE WOULD BE A RECORD IN THE FILE WHICH, 
C---	GEOMETRICALLY, BELONGS TO THE NEXT REV, (AND IS NORTH OF THE EQUATOR)
C---	WHILE ITS TIME BELONGS TO THE CURRENT REV, USING THE DESIRED NODAL 
C---	PERIOD AS THE CRITERION.  
C---	WE WANT TO SUPPRESS THE PROCESSING OF THAT RECORD, SINCE THE NEXT RECORD
C---	WRITTEN WILL BE FROM THE BEGINNING OF THE FILE AND AT THE EQUATOR, 
C---	RESULTING IN A ZIGZAG GROUND TRACK.  
C
C---	IN OTHER WORDS, IF THE REV STARTED AT THE ASCENDING NODE, THEN THERE 
C---	WOULD BE A SLIGHT CHANCE THAT THERE WOULD BE A RECORD 'R' WRITTEN WITH 
C---	A SUBSAT LATITUDE ABOVE THE EQUATOR, WITH A TIME JUST BEFORE THE END OF 
C---	THE DESIRED NODAL PERIOD.  THEN WHEN THE NEXT RECORD IS WRITTEN AFTER 
C---	REWINDING THE FILE, THE LATITUDE OF THE NEXT RECORD WOULD BE ZERO, 
C---	MAKING AN UNDESIREABLE ZIGZAG IN THE GROUND TRACK.  
C---	BETTER TO PREVENT THE WRITING OF THAT RECORD 'R'.  
C---	SO NOW WE NOTE DATA FROM THE FIRST RECORD IN THE FILE TO SUPPORT 
C---	THE PREVENTION OF WRITING SUCH A RECORD.  
      IF(PRINTFLAG .EQ. 1)
     ?   WRITE(*,*)' RGETX:  FIRST TIME THROUGH THE INPUT FILE.'
      IFIRST = 0
      XR1 = XR
      XLAT1 = XLAT
      VZ1 = V(3)
      TREC1 = TREC
      TRECN = TIME1 + TNODE
      TRECN90 = TIME1 + (TNODE * 0.90d00)
      IF(PRINTFLAG .EQ. 1)
     ?   WRITE(*,*)' RGETX:  XR1 = ', XR1
      IF(PRINTFLAG .EQ. 1)
     ?   WRITE(*,*)' RGETX:  XLAT1 = ', XLAT1
      IF(PRINTFLAG .EQ. 1)
     ?   WRITE(*,*)' RGETX:  VZ1 = ', VZ1
      IF(PRINTFLAG .EQ. 1)
     ?   WRITE(*,*)' RGETX:  TREC1 = ', TREC1
      IF(PRINTFLAG .EQ. 1)
     ?   WRITE(*,*)' RGETX:  TRECN = ', TRECN
      IF(PRINTFLAG .EQ. 1)
     ?   WRITE(*,*)' RGETX:  TRECN90 = ', TRECN90
 3000 CONTINUE
C---	COMPUTE TIME FOR OUTPUT RECORD.  CHECK FOR END OF RUN.  
C---	SET T = THE OUTPUT REC TIME.  
      T = TREC + DT
C---	NOW CHECK FOR TREC PAST OR = THE DESIRED NODAL PERIOD.  
C---	TEST WITH THE TIME (TREC) FROM THE INPUT FILE REC.  
      IF(TREC .GE. TRECN ) GO TO 1000
C---	NOW BEGIN CHECKING FOR THE PREVENTION OF PRINTING RECORD 'R'.
C---    see explanation above.  
C---	IF THIS A RECORD 'R', THEN WE:  
C---			GO TO 1000 
C---	AND REWIND THE FILE.  IF THIS IS NOT A RECORD 'R', 
C---	THEN WE GO TO 4000 AND WRITE THE RECORD.  NO NEED TO 
C---	CHECK UNTIL WE ARE NEAR THE NODAL PERIOD.  WE ASSUME THAT 
C---	THE NODAL PERIOD IS NEAR THE DESIRED NODAL PERIOD.  
C---	USE TREC FROM THE INPUT RECORD FOR THE TEST.  
      IF(TREC .LE. TRECN90) GO TO 4000
      IF( XR .LE. XR1) GO TO 4000
      IF(VZ1 .EQ. 0.0D0) GO TO 4000
      IF(VZ1 .GT. 0.0D0) GO TO 3500
C
C---	DESCENDING AT THE START OF THE FILE.
      IF(V(3) .GE. 0.0D0) GO TO 4000
C---	DESCENDING RIGHT NOW.  CHECK FOR THIS RECORD LOWER THAN FIRST REC.
      IF(XLAT .LE. XLAT1 ) GO TO 1000
      GO TO 4000
 3500 CONTINUE
C---	ASCENDING AT THE START OF THE FILE.
      IF(V(3) .LE. 0.0D0) GO TO 4000
C---	ASCENDING RIGHT NOW.  CHECK FOR THIS RECORD HIGHER THAN FIRST REC.
      IF(XLAT .GE. XLAT1 ) GO TO 1000
C
 4000 CONTINUE
C---	THIS IS NOT A RECORD 'R'.  
C---	IF THIS TIME IS BEFORE THE OUTPUT START, SKIP TO THE NEXT RECORD.
C---	DUE TO THE PRECISION OF ABOUT .864 MILLISECONDS IN G_FLOAT (10E-8 days)
C---				  AND .086 MILLISECONDS IN D_FLOAT (10E-9 days)
C---	WE NEED TO ADJUST THE BRACKET TO PICK UP THE DESIRED RECORDS.
      IF(T .LT. TFIRST - 6.0d-9) GO TO 2000
C---	IF THIS TIME IS AFTER THE OUTPUT END TIME, GO TO THE FINISH.  
      IF(T .GT. TLAST  + 6.0d-9 ) GO TO 7000
      CALL VECROT(X,XROT,X1)
      CALL VECROT(V,XROT,V1)
C---	REV #
      XR = XR + J
C---	LONGITUDE OF ASCENDING NODE, WRT VERNAL EQUINOX.  
      XLASC = XLASC + XROT
      XLASC = MOD(XLASC,360.0D0)
C---	SUBSAT LONGITUDE:  WESTWARD DRIFT. 
      XLON = XLON - DL
      XLON = MOD(XLON,360.0D0)
      IF(XLON .LT. 0.0D0) XLON = XLON + 360.0D0
      GHA = GHA + DGHA
      GHA = MOD(GHA,360.0D0)
C---	ALL DONE; NOW LOAD UP THE ARRAY x12:
      x12(1) = X1(1)
      x12(2) = X1(2)
      x12(3) = X1(3)
      x12(4) = V1(1)
      x12(5) = V1(2)
      x12(6) = V1(3)
      x12(7) = T
      x12(8) = XR
      x12(9) = XLASC
      x12(10) = XLAT
      x12(11) = XLON
      x12(12) = GHA
C---	THE X12 RECORD IS LOADED; NOW RETURN.  
      RGETX = .FALSE.
      GO TO 9999
 7000 CONTINUE
C---	THE JOB IS DONE.  
      RGETX = .TRUE.
 9999 CONTINUE
      RETURN
      END
********************************************************************
*  Name:	VECROT
*  Module Type: SUBROUTINE 	Language: FORTRAN
*  Purpose:	ROTATE A VECTOR ABOUT THE POSITIVE Z DIRECTION BY 
*		ADEG DEGREES.  
*  Functions called:
*  Input Parameters:
*  Name         Type    Definition
*  V(3)		REAL*8	INPUT VECTOR.
*  ADEG		REAL*8	AMOUNT TO ROTATE THE VECTOR ABOUT +Z AXIS.
*  Output Parameters:
*  Name         Type    Definition
*  VROT(3)	REAL*8	RESULT VECTOR.  
*  Variables:
*  Locals :
*  Externals :
*  Modification History:                                            
*  Date			Revision	Author
*  $Date$Revision$ $Author$
*                                                                   
*********************************************************************/
      SUBROUTINE VECROT (V,DEG,VROT)
      IMPLICIT NONE
      REAL*8 V(3), DEG, VROT(3)
      REAL*8 VXY(3), VXYP(3)
C---	COMPUTE VXY, VECTOR IN THE XY PLANE IN THE DIRECTION OF
C---	THE PROJECTION OF V.
      VXY(1) = V(1) 
      VXY(2) = V(2) 
C---	COMPUTE VXYP, VECTOR IN THE XY PLANE RESULTING FROM 
C---	ZUNIT X VXY.  THIS IS A VECTOR PERP TO VXYU, 90 DEG IN THE POSITIVE 
C---	DIRECTION.  
      VXYP(1) = - VXY(2) 
      VXYP(2) = VXY(1)
C---	O.K.  
C---	NOW THE RESULT VECTOR IS ( COS(DEG)*VXY + SIN(DEG)*VXYP)
C---
C---	THINK OF THE PROJECTION OF V DOWN TO THE XY PLANE AS THE X-AXIS
C---	AND THE PERPENDICULAR TO IT AS THE Y AXIS, THEN USE SIN AND COS OF DEG
C---	TO YIELD THE RESULT VECTOR.  
      VROT(1) = COSD(DEG) * VXY(1) + SIND(DEG) * VXYP(1)
      VROT(2) = COSD(DEG) * VXY(2) + SIND(DEG) * VXYP(2)
      VROT(3) = V(3)
      RETURN
      END
