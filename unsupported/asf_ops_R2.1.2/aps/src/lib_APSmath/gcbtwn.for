C--  Copyright (c)1996, California Institute of Technology.
C--  U.S. Government Sponsorship acknowledged.

********************************************************************
*  Name:	GCBTWN
*  Module Type: SUBROUTINE	Language: FORTRAN
*  $Logfile:   ACS003:[BLD.MPS.LIB.SRC]GCBTWN.FOV  $
*  Purpose:	DETERMINE IF A UNIT VECTOR IS BETWEEN 2 OTHER UNIT VECTORS
*		IN THE SAME PLANE.  THAT IS, IF YOU DRAW A GREAT CIRCLE ON A 
*		UNIT SPHERE BETWEEN THE TWO POINTS, IS THE TEST POINT ON IT?
*  Subroutines called:
*  GCBOMB, GCLOSE
*  VECTOR LIBRARY: UCROSS, VUNIT, VUNITN, DOT
*  Input Parameters:
*  3 POINTS ON A UNIT SPHERE, (X,Y,Z)
*  Name         Type    Definition
*  P1		REAL*8	FIRST POINT OF SEGMENT P
*  P2		REAL*8	END POINT OF SEGMENT P
*  X		REAL*8	TEST POINT
*  Output Parameters:
*  Name         Type    Definition
*  IFLAG	INTEGER	
*			=  1 IF  X IS BETWEEN P1 AND P2
*			= -1 IF -X IS BETWEEN P1 AND P2
*			=  0 IF NEITHER ARE BETWEEN P1 AND P2
*  Variables:
*  Locals :
*  Externals :
*  Modification History:                                            
*  Date			Revision	Author
*  $Date$ $Revision$ $Author$
*                                                                   
*********************************************************************/
      SUBROUTINE GCBTWN (IFLAG,P1,P2,X)
      character*100 SccsFileID
     -/'@(#)gcbtwn.for	5.1 98/01/08 APS/ASF\0'/

      IMPLICIT NONE
      REAL*8 X(3), P1(3), P2(3)
      REAL*8 XNEG(3), P1X(3), P2X(3), XTRY(3), PP(3)
      REAL*8 D1, D2
C---	FUNCTION FROM VECTOR LIBRARY
      REAL*8 DOT
      INTEGER IFLAG, ITRY
      IFLAG = 0
C---	CHECK FOR CLOSENESS OF X/-X TO P1 OR P2.  GCLOSE RETURNS +1 IF X IS 
C---	CLOSE, -1 IF -X IS CLOSE.  
      CALL GCLOSE(IFLAG,X,P1)
C---	IF FLAG .NE.0 THEN RETURN THE VALUE IFLAG.
      IF (IFLAG .NE. 0 ) GO TO 9999
C---	WE DO NOT HAVE CLOSENESS FOR P1 ON EITHER X OR XNEG. 
C---	CHECK FOR CLOSENESS OF X TO P2.  
      CALL GCLOSE(IFLAG,X,P2)
      IF (IFLAG .NE. 0 ) GO TO 9999
C---	OK.  NO CLOSENESS.
C---	NOW CHECK P1 VS P2:
      CALL GCLOSE(IFLAG,P1,P2)
      IF(IFLAG.EQ.0) GO TO 2000
      IF(IFLAG.EQ.-1) GO TO 1000
C---	SPECIAL CASE:  P1=P2  IFLAG WAS = 1.  
C---	RETURN FLAG OF 0.  DO NOT HAVE TO BOMB THE PROGRAM.  
      IFLAG = 0
      GO TO 9999
 1000 CONTINUE
C---	SPECIAL CASE:  P1=-P2 
C---	IN THESE CASES WHERE THE SEGMENT IS UNDEFINED, CAUSE A BOMB.
C---	CLOSENESS OF X OR -X TO P1 OR P2 WAS A MITIGATING CIRCUMSTANCE ABOVE.
      CALL GCBOMB
 2000 CONTINUE
C---	O.K.  THE NORMAL MODE:  
C---	BUT WAIT:  CHECK FOR ALL IN THE SAME PLANE.  
C---	COMPUTE UNIT NORM TO PLANE P.
      CALL UCROSS(PP,P1,P2)
C---	NOW SEE IF X IS PERPENDICULAR TO NORMAL PP.  IF NOT, NO INTERSECTION.
      D1 = ABS(DOT(X,PP,3))
      IF(D1 .GT. 1.0D-09) GO TO 9999
C---	THE ANGLE BETWEEN X AND THE PLANE WAS LESS THAN 5.73 x 10**-8 DEGREES.
C---	ON THE EARTH, THIS WOULD BE 3.77 x 10**-6 NAUTICAL MILES.  
C---				 OR 6.98 x 10**-6 KILOMETERS
C---				 OR 6.98          MILLIMETERS
C---	SO THEY ARE IN THE SAME PLANE.  
C---	WE CAN NOW CONTINUE
      CALL VUNITN(XNEG,X,3)
C---	NOW IF EITHER UNIT VECTORS X OR XNEG LIE BETWEEN P1 AND P2, THEN THE
C---	FLAG VALUE OF +1 OR -1 IS RETURNED.  IF NOT, 0 IS RETURNED.
C---	FIRST COMPUTE UNIT VECTORS P1X = P1 X X
      CALL UCROSS(P1X,P1,X)
C---				AND P2X = P1 X XNEG
      CALL UCROSS(P2X,P1,XNEG)
C---	ONE OF THESE WILL COINCIDE WITH PP ABOVE, THE OTHER WILL BE -PP.
C---	COINCIDENCE WILL BE OBSERVED WHEN THE DOT PRODUCT IS VERY CLOSE TO 
C---	1.0.  (BOTH PP AND P1X ARE UNIT VECTORS, SO YOU GET JUST THE COSINE OF
C---	THE ANGLE BETWEEN THEM.  )
      D1 = DOT(P1X,PP,3)
CCC      WRITE(*,*)'GCBTWN: D1=',D1
      D2 = DOT(P2X,PP,3)
CCC      WRITE(*,*)'GCBTWN: D2=',D2
C---	TAKE THE ONE WHICH EQUALS PP AND THE VECTOR (X OR XNEG) WHICH PRODUCED
C---	THE COINCIDENCE.  CALL THIS VECTOR (X OR XNEG) XTRY.  
      IF( ABS(D1 - 1.0) .LT. 0.0001) ITRY = 1
      IF( ABS(D1 - 1.0) .LT. 0.0001) CALL VUNIT(XTRY,X,3)
      IF( ABS(D2 - 1.0) .LT. 0.0001) ITRY = -1
      IF( ABS(D2 - 1.0) .LT. 0.0001) CALL VUNIT(XTRY,XNEG,3)
C--	NOW XTRY IS REACHED FROM P1 BY MOVING TOWARDS P2 AND TRAVELING 
C---	LESS THAN 180 DEGREES AROUND.  
C---	NOW TAKE THE DOT PRODUCTS OF THE VECTORS:
C---		D1 = (P1 . XTRY)
      D1 = DOT(P1,XTRY,3)
C---		D2 = (P1 . P2)
      D2 = DOT(P1,P2,3)
C---	D1 AND D2 ARE THE COSINES OF THE ANGLES BETWEEN THE VECTORS.  
C---	IF D1 .GE. D2, THEN WE KNOW THAT XTRY IS BETWEEN P1 AND P2.
C---	IF D1 .LT. D2, THEN WE KNOW THAT P2 IS BETWEEN P1 AND XTRY 
C---	AND WE RETURN 0, NEITHER X NOR XNEG WAS BETWEEN P1 AND P2.  
      IFLAG = 0
      IF(D1 .LT. D2) GO TO 9999
C---	O.K.  XTRY IS BETWEEN P1 AND P2.  
      IFLAG = ITRY
 9999 CONTINUE
CCC      WRITE(*,*)'GCBTWN:  IFLAG=',IFLAG
      RETURN
      END
