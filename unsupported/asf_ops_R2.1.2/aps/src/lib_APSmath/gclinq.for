C--  Copyright (c)1996, California Institute of Technology.
C--  U.S. Government Sponsorship acknowledged.

********************************************************************
*  Name:	GCLINQ
*  Module Type: SUBROUTINE	Language: FORTRAN
*  $Logfile:   ACS003:[BLD.MPS.LIB.SRC]GCLINQ.FOV  $
*  Purpose:	COMPUTE AT WHAT POINT THE SEGMENT SL1 SL2 INTERSECTS THE 
*		QUADRILATERAL WHILE ENTERING IT.  THIS IS RETURNED AS A 
*		FRACTION F OF THE DISTANCE TRAVELLED FROM SL1 TO SL2.
*		IF SL1 IS ALREADY INSIDE IT, F = 0 IS RETURNED.  
*		IF THE SEGMENT NEVER ENTERS Q, F = -1.0 IS RETURNED.
*		SL1 SL2 IS CONSIDERED TO BE THE LEFT BOUNDARY OF A SENSOR 
*		SWATH WHEN APPROPRIATE FOR SPECIAL CASES.
*  Subroutines called:
*  VECTOR LIBRARY: UCROSS, VUNIT, VUNITN
*  Input Parameters:
*  POINTS ON A UNIT SPHERE, (X,Y,Z)
*  Name         Type    Definition
*  SL1		REAL*8	FIRST POINT OF SEGMENT SL
*  SL2		REAL*8	SECOND POINT OF SEGMENT SL
*  Q1		REAL*8	1ST POINT OF QUADRILATERAL
*  Q2		REAL*8	2ND POINT OF QUADRILATERAL
*  Q3		REAL*8	3RD POINT OF QUADRILATERAL
*  Q4		REAL*8	4TH POINT OF QUADRILATERAL
*			NOTE:  THE POINTS ARE ENTERED IN A CLOCKWISE 
*			DIRECTION.  
*  Output Parameters:
*  Name         Type    Definition
*  F		REAL*8	FRACTION OF DISTANCE SL1 SL2 TRAVELED TO ENTER THE 
*			QUADRILATERAL:  0 <= F < 1.0
*			IF NO ENTRY, F = -1.0
*  Variables:
*  Locals :
*  Externals :
*  Modification History:                                            
*  Date			Revision	Author
*  $Date$ $Revision$ $Author$
*                                                                   
*********************************************************************/
      SUBROUTINE GCLINQ (F,SL1,SL2,Q1,Q2,Q3,Q4)
      character*100 SccsFileID
     -/'@(#)gclinq.for	5.1 98/01/08 APS/ASF\0'/

      IMPLICIT NONE
      REAL*8 F,SL1(3),SL2(3),Q1(3),Q2(3),Q3(3),Q4(3)
      REAL*8 X(3), D12, D1X
      INTEGER IFLAG
      F = 0.0D00
      CALL GCPINQ(IFLAG,Q1,Q2,Q3,Q4,SL1)
C--	SEE IF SL1 IS INSIDE BUT NOT ON THE EDGE.  
      IF(IFLAG .EQ. 1) GO TO 9999
C---	NOT INSIDE BUT COULD BE ON THE EDGE.  
C---	IF ON THE EDGE, CHECK IF A POINT SLIGHTLY ON SL AND SLIGHTLY
C---	TOWARDS SL2 IS DEFINITELY INSIDE AND NOT ON THE EDGE.  
C---	IF SO, THEN COVERAGE STARTS RIGHT AWAY.  
      IF(IFLAG .NE. 0) GO TO 1000
C---	SL1 IS ON THE EDGE.  USE D = 10 METERS.
C---	THIS MEANS THAT CONVERTING 1.57D-6 RADIANS TO DEGREES AND THEN
C---	TO NAUTICAL MILES, YOU GET 10 METERS.
      CALL GCTRAV(X,SL1,SL2,1.57D-6)
      CALL GCPINQ(IFLAG,Q1,Q2,Q3,Q4,X)
C---	IF THIS POINT IS INSIDE AND NOT ON THE EDGE, THEN 
C---	COVERAGE STARTS.  
      IF(IFLAG .EQ. 1) GO TO 9999
 1000 CONTINUE
C---	MUST CONTINUE TO LOOK FOR START COVERAGE.  
      CALL GCDIST(D12,SL1,SL2)
C---	CHECK EACH OF THE 4 SIDES FOR ENTRY.  
C---	THE SIDE HAS TO GO IN WITH THE LEFT POINT FIRST:  Q2 Q1.
      CALL GCLOVR(IFLAG,X,SL1,SL2,Q2,Q1)
      IF(IFLAG.EQ.1) GO TO 9000
C---	NO INTERSECTION; KEEP TRYING.
      CALL GCLOVR(IFLAG,X,SL1,SL2,Q3,Q2)
      IF(IFLAG.EQ.1) GO TO 9000
C---	NO INTERSECTION; KEEP TRYING.
      CALL GCLOVR(IFLAG,X,SL1,SL2,Q4,Q3)
      IF(IFLAG.EQ.1) GO TO 9000
C---	NO INTERSECTION; KEEP TRYING.
      CALL GCLOVR(IFLAG,X,SL1,SL2,Q1,Q4)
      IF(IFLAG.EQ.1) GO TO 9000
C---	NO INTERSECTION.  STOP TRYING.
      F = -1.0D00
      GO TO 9999
 9000 CONTINUE
C---	INTERSECTION FOUND.  
      CALL GCDIST(D1X,SL1,X)
      F = D1X / D12
 9999 CONTINUE
      RETURN
      END
