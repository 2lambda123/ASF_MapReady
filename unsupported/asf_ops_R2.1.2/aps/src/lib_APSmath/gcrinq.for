C--  Copyright (c)1996, California Institute of Technology.
C--  U.S. Government Sponsorship acknowledged.

********************************************************************
*  Name:	GCRINQ
*  Module Type: SUBROUTINE	Language: FORTRAN
*  $Logfile:   ACS003:[BLD.MPS.LIB.SRC]GCRINQ.FOV  $
*  Purpose:	COMPUTE AT WHAT POINT THE SEGMENT SR1 SR2 INTERSECTS THE 
*		QUADRILATERAL WHILE ENTERING IT.  THIS IS RETURNED AS A 
*		FRACTION F OF THE DISTANCE TRAVELLED FROM SR1 TO SR2.
*		IF SR1 IS ALREADY INSIDE IT, F = 0 IS RETURNED.  
*		IF THE SEGMENT NEVER ENTERS Q, F = -1.0 IS RETURNED.
*		SR1 SR2 IS CONSIDERED TO BE THE RIGHT BOUNDARY OF A SENSOR 
*		SWATH WHEN APPROPRIATE FOR SPECIAL CASES.
*  Subroutines called:
*  VECTOR LIBRARY: UCROSS, VUNIT, VUNITN
*  Input Parameters:
*  POINTS ON A UNIT SPHERE, (X,Y,Z)
*  Name         Type    Definition
*  SR1		REAL*8	FIRST POINT OF SEGMENT SR
*  SR2		REAL*8	SECOND POINT OF SEGMENT SR
*  Q1		REAL*8	1ST POINT OF QUADRILATERAL
*  Q2		REAL*8	2ND POINT OF QUADRILATERAL
*  Q3		REAL*8	3RD POINT OF QUADRILATERAL
*  Q4		REAL*8	4TH POINT OF QUADRILATERAL
*			NOTE:  THE POINTS ARE ENTERED IN A CLOCKWISE 
*			DIRECTION.  
*  Output Parameters:
*  Name         Type    Definition
*  F		REAL*8	FRACTION OF DISTANCE SR1 SR2 TRAVELED TO ENTER THE 
*			QUADRILATERAL:  0 <= F < 1.0
*			IF NO ENTRY, F = -1.0
*  Variables:
*  Locals :
*  Externals :
*  Modification History:                                            
*  Date			Revision	Author
*  $Date$ $Revision$ $Author$
*                                                                   
*********************************************************************/
      SUBROUTINE GCRINQ (F,SR1,SR2,Q1,Q2,Q3,Q4)
      character*100 SccsFileID
     -/'@(#)gcrinq.for	5.1 98/01/08 APS/ASF\0'/

      IMPLICIT NONE
      REAL*8 F,SR1(3),SR2(3),Q1(3),Q2(3),Q3(3),Q4(3)
      REAL*8 X(3), D12, D1X
      INTEGER IFLAG
      F = 0.0D00
      CALL GCPINQ(IFLAG,Q1,Q2,Q3,Q4,SR1)
C--	SEE IF SR1 IS INSIDE.  
      IF(IFLAG .EQ. 1) GO TO 9999
C---	NOT INSIDE BUT COULD BE ON THE EDGE.  
C---	IF ON THE EDGE, CHECK IF A POINT SLIGHTLY ON SR AND SLIGHTLY
C---	TOWARDS SR2 IS DEFINITELY INSIDE AND NOT ON THE EDGE.  
C---	IF SO, THEN COVERAGE STARTS RIGHT AWAY.  
      IF(IFLAG .NE. 0) GO TO 1000
C---	SR1 IS ON THE EDGE.  USE D = 10 METERS.
      CALL GCTRAV(X,SR1,SR2,1.57D-6)
      CALL GCPINQ(IFLAG,Q1,Q2,Q3,Q4,X)
C---	IF THIS POINT IS INSIDE AND NOT ON THE EDGE, THEN 
C---	COVERAGE STARTS.  
      IF(IFLAG .EQ. 1) GO TO 9999
 1000 CONTINUE
C---	MUST CONTINUE TO LOOK FOR START COVERAGE.  
      CALL GCDIST(D12,SR1,SR2)
C---	CHECK EACH OF THE 4 SIDES FOR ENTRY.  
C---	THE GCROVR HAS TO RECEIVE THE QUADRILATERAL SIDE SIDE WITH THE LEFT 
C---	POINT FIRST:  Q2 Q1.
      CALL GCROVR(IFLAG,X,SR1,SR2,Q2,Q1)
      IF(IFLAG.EQ.1) GO TO 9000
C---	NO INTERSECTION; KEEP TRYING.
      CALL GCROVR(IFLAG,X,SR1,SR2,Q3,Q2)
      IF(IFLAG.EQ.1) GO TO 9000
C---	NO INTERSECTION; KEEP TRYING.
      CALL GCROVR(IFLAG,X,SR1,SR2,Q4,Q3)
      IF(IFLAG.EQ.1) GO TO 9000
C---	NO INTERSECTION; KEEP TRYING.
      CALL GCROVR(IFLAG,X,SR1,SR2,Q1,Q4)
      IF(IFLAG.EQ.1) GO TO 9000
C---	NO INTERSECTION.  STOP TRYING.
      F = -1.0D00
      GO TO 9999
 9000 CONTINUE
C---	INTERSECTION FOUND.  
      CALL GCDIST(D1X,SR1,X)
      F = D1X / D12
 9999 CONTINUE
      RETURN
      END
