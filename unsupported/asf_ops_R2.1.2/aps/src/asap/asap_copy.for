C--  Copyright (c)1996, California Institute of Technology.
C--  U.S. Government Sponsorship acknowledged.
C-- ==========================================================================
C--
C--  Fortran Filename:	asap_copy.for
C--
C--  Description:	
C--	
C--  Notes:
C--
C-- ==========================================================================

********************************************************************
*  Name:	ASAP_COPY
c---port   not necessary	COMPILE IN G_FLOATING
*	COMPILE IN G_FLOATING
*	COMPILE IN G_FLOATING
*  Module Type: SUBROUTINE 	Language: FORTRAN
*  $Logfile:   ACS003:[BLD.MPS.EPHM.SRC]ASAP_COPY.FOV  $
*  Purpose:	REPLICATE EPHEMERIS DATA FROM UNIT 80 (BINARY)
*		TO UNITS 90 (BINARY) AND 99 (ASCII) AND DELETING 
*		UNITS 80 AND 88.
*  Functions called:
*  VECTOR LIBRARY:  SPHERE
*  Input Parameters:
*  Name         Type    Definition
*  TIME1	REAL*8	START TIME OF INPUT FILE 
*  TIME2	REAL*8	END TIME IN THE INPUT FILE (ALLOWS FOR A BIT MORE THAN
*			THE DESIRED NODAL PERIOD.)
*  TFIRST	REAL*8	START TIME OF OUTPUT AS REQUESTED BY USER IN 
*			THE v_ephmasap FRAME.  
*  TLAST	REAL*8	END TIME OF OUTPUT AS REQUESTED BY USER IN 
*			THE v_ephmasap FRAME.  
*  TNODE	REAL*8	NODAL PERIOD FOR THE SATELLITE.  
*  Output Parameters:
*  Name         Type    Definition
*  RFIRST	INT*4	FIRST REV # IN THE OUTPUT FILE. 
*  RLAST	INT*4	LAST REV # IN THE OUTPUT FILE. 
*  Variables:
*  Locals :
*  Externals :
*  Modification History:                                            
*  Date			Revision	Author
*  $Date$ $Revision$ $Author$
*                                                                   
*********************************************************************/
c--port      OPTIONS /G_FLOATING
      SUBROUTINE ASAP_COPY(TIME1,TIME2,TFIRST,TLAST,TNODE,RFIRST,RLAST)

      character*100 SccsFileID
     -/'@(#)asap_copy.for	5.1 98/01/08 APS/ASF\0'/

      IMPLICIT NONE
      INTEGER RFIRST, RLAST, J
      REAL*8 TIME1, TIME2, TFIRST, TLAST, TNODE, XDUM
      REAL*8 X(3), V(3), T, XR, XLASC, XLAT, XLON, GHA
      REAL*8 X1(3), V1(3), DT, XROT, DL, DGHA, XREVS
      REAL*8         TSECS, TMILLI
      INTEGER IDAYS, ISECS, IMILLI
      INTEGER IFIRST, IFIRSTW, NRECS
      REAL*8 TREC, XR1, XLAT1, VZ1, TREC1, TRECN, TRECN90
      CHARACTER*1 nodeflag
      INCLUDE 'APS_HOME:include/local/mps_const_earth.inc'
C---	OPEN THE INPUT FILE.  
      WRITE(*,*) ' ASAP_COPY START:'
      WRITE(*,*)' ASAP_COPY:  TIME1 = ', TIME1
      WRITE(*,*)' ASAP_COPY:  TIME2 = ', TIME2
      WRITE(*,*)' ASAP_COPY:  TFIRST = ', TFIRST
      WRITE(*,*)' ASAP_COPY:  TLAST = ', TLAST
      WRITE(*,*)' ASAP_COPY:  TNODE = ', TNODE
      WRITE(*,*)' ASAP_COPY:  RLAST = ', RLAST
      CLOSE (88,DISPOSE='DELETE')
C---	WRITE THE EPOCH.  
      WRITE (90) TIME1
      WRITE (99,*) TIME1
      IFIRST = 1
      IFIRSTW = 1
      NRECS = 0
C---	COMPUTE THE REV FOR TFIRST.  
      XREVS = TFIRST - TIME1
      WRITE(*,*)' ASAP_COPY:  DIF TFIRST - TIME1 = ', XREVS
      XREVS = (TFIRST - TIME1)/TNODE
      WRITE(*,*)' ASAP_COPY:  XREVS = ', XREVS
      J = XREVS 
      J = J - 1
      IF(J .LT. -1) J = -1
      WRITE(*,*)' ASAP_COPY:  AT START:  J = ', J
 1000 CONTINUE
      J = J + 1
C---	POSITION TO START OF THE FILE.  
      REWIND 80
      READ(80)XDUM
C---	SET UP THE INCREMENTS BETWEEN THE FILE AND THE OUTPUT FOR THIS REV.
C---	(FIRST TIME THROUGH, THE INCREMENTS ARE ACCORDING TO THE NUMBER OF REVS
C---	BETWEEN TIME1 AND TFIRST.  )
C---	TIME (DAYS)
C---	NOTE THAT WE WANT TO ROUND OFF THE DT TO THE NEAREST MILLISECOND.  
C---	SO WE ADD 1/2 A MILLISEC TO THE DT, THEN TRUNCATE TO GET THE INTEGER 
C---	DAYS, SECS, AND MILLIES, THEN RECOMPUTE THE DT BASED ON THOSE INTEGERS.
      DT = J * TNODE    + (0.5D0 / 86400 000)
      WRITE (*,*) ' DT + 1/2 MILLI = ', DT
      IDAYS = DT
      TSECS =   ( (DT-IDAYS) * 86400)
      ISECS = TSECS
      TMILLI = ((TSECS - ISECS) * 1000) 
      IMILLI = TMILLI
      WRITE (*,*)' IDAYS, ISECS, IMILLI = ',IDAYS,' ',ISECS,' ',IMILLI
      DT = IDAYS + ((ISECS/86400.0D0) + (IMILLI/86400 000.0D0))
C-----      WRITE(*,*)' ASAP_COPY:  DT = ', DT
C---	ROTATION (DEGREES) OF VECTORS IN INERTIAL SYSTEMS: ONE CYCLE PER YEAR
C---	IN A FORWARD DIRECTION.  REPRESENTS THE ORBIT PRECESSING IN A 
C---	SUN-SYNCHRONOUS MANNER.
      XROT = (DT / EYEAR) * 360.0D0
      XROT = MOD(XROT,360.0D0)
C---	REVS = J
C---	SUBSAT LONGITUDE:  WESTWARD DRIFT. 
C---	DT IS GIVEN IN DAYS.  DRIFT PER NODAL PERIOD IS FRACTION OF DAY*360.
      DL = DT*360.0D0
C---	GREENWICH HOUR ANGLE:  DT * RATE OF EARTH ROTATION (DEG/DAY)
      DGHA = DT * EROTI * 360.0D0
      DGHA = MOD(DGHA,360.0D0)
 2000 CONTINUE
      READ(80,END=1000)nodeflag, X, V, TREC, XR, XLASC,XLAT,XLON,GHA
      IF(IFIRST .NE. 1) GO TO 3000
C---	FIRST TIME THROUGH IN THIS RUN.  
C---	SET UP LIMITS TO PREVENT THE WRITING OF RECORDS WHICH WILL NOT MESH 
C---	WITH THE RECORDS WRITTEN IN THE NEXT READ OF THE FILE.  
C
C---	FOR EXAMPLE, SUPPOSE THE RUN OF ASAP WAS GIVEN A STATE VECTOR AT 
C---	THE ASCENDING NODE WITH A SEMIMAJOR AXIS THAT WAS A BIT SHORT.  THIS 
C---	WOULD RESULT IN A NODAL PERIOD LESS THAN THE DESIRED NODAL PERIOD.  
C---	THE DANGER IS THAT THERE WOULD BE A RECORD IN THE FILE WHICH, 
C---	GEOMETRICALLY, BELONGS TO THE NEXT REV, (AND IS NORTH OF THE EQUATOR)
C---	WHILE ITS TIME BELONGS TO THE CURRENT REV, USING THE DESIRED NODAL 
C---	PERIOD AS THE CRITERION.  
C---	WE WANT TO SUPPRESS THE PROCESSING OF THAT RECORD, SINCE THE NEXT RECORD
C---	WRITTEN WILL BE FROM THE BEGINNING OF THE FILE AND AT THE EQUATOR, 
C---	RESULTING IN A ZIGZAG GROUND TRACK.  
C
C---	IN OTHER WORDS, IF THE REV STARTED AT THE ASCENDING NODE, THEN THERE 
C---	WOULD BE A SLIGHT CHANCE THAT THERE WOULD BE A RECORD 'R' WRITTEN WITH 
C---	A SUBSAT LATITUDE ABOVE THE EQUATOR, WITH A TIME JUST BEFORE THE END OF 
C---	THE DESIRED NODAL PERIOD.  THEN WHEN THE NEXT RECORD IS WRITTEN AFTER 
C---	REWINDING THE FILE, THE LATITUDE OF THE NEXT RECORD WOULD BE ZERO, 
C---	MAKING AN UNDESIREABLE ZIGZAG IN THE GROUND TRACK.  
C---	BETTER TO PREVENT THE WRITING OF THAT RECORD 'R'.  
C---	SO NOW WE NOTE DATA FROM THE FIRST RECORD IN THE FILE TO SUPPORT 
C---	THE PREVENTION OF WRITING SUCH A RECORD.  
      WRITE(*,*)' ASAP_COPY:  FIRST TIME THROUGH THE INPUT FILE.'
      IFIRST = 0
      XR1 = XR
      XLAT1 = XLAT
      VZ1 = V(3)
      TREC1 = TREC
      TRECN = TIME1 + TNODE
      TRECN90 = TIME1 + (TNODE * 0.90d00)
      WRITE(*,*)' ASAP_COPY:  XR1 = ', XR1
      WRITE(*,*)' ASAP_COPY:  XLAT1 = ', XLAT1
      WRITE(*,*)' ASAP_COPY:  VZ1 = ', VZ1
      WRITE(*,*)' ASAP_COPY:  TREC1 = ', TREC1
      WRITE(*,*)' ASAP_COPY:  TRECN = ', TRECN
      WRITE(*,*)' ASAP_COPY:  TRECN90 = ', TRECN90
 3000 CONTINUE
C---	COMPUTE TIME FOR OUTPUT RECORD.  CHECK FOR END OF RUN.  
C---	SET T = THE OUTPUT REC TIME.  
      T = TREC + DT
C---	NOW CHECK FOR TREC PAST OR = THE DESIRED NODAL PERIOD.  
C---	TEST WITH THE TIME (TREC) FROM THE INPUT FILE REC.  
      IF(TREC .GE. TRECN ) GO TO 1000
C-----      WRITE(*,*)' ASAP_COPY:  PLACE 1'
C---	NOW BEGIN CHECKING FOR THE PREVENTION OF PRINTING RECORD 'R'.
C---	IF THIS A RECORD 'R', THEN WE:  
C---			GO TO 1000 
C---	AND REWIND THE FILE.  IF THIS IS NOT A RECORD 'R', 
C---	THEN WE GO TO 4000 AND WRITE THE RECORD.  NO NEED TO 
C---	CHECK UNTIL WE ARE NEAR THE NODAL PERIOD.  WE ASSUME THAT 
C---	THE NODAL PERIOD IS NEAR THE DESIRED NODAL PERIOD.  
C---	USE TREC FROM THE INPUT RECORD FOR THE TEST.  
      IF(TREC .LE. TRECN90) GO TO 4000
C-----      WRITE(*,*)' ASAP_COPY:  PLACE 2'
      IF( XR .LE. XR1) GO TO 4000
C-----      WRITE(*,*)' ASAP_COPY:  PLACE 3'
      IF(VZ1 .EQ. 0.0D0) GO TO 4000
C-----      WRITE(*,*)' ASAP_COPY:  PLACE 4'
      IF(VZ1 .GT. 0.0D0) GO TO 3500
C-----      WRITE(*,*)' ASAP_COPY:  PLACE 5'
C
C---	DESCENDING AT THE START OF THE FILE.
      IF(V(3) .GE. 0.0D0) GO TO 4000
C-----      WRITE(*,*)' ASAP_COPY:  PLACE 6'
C---	DESCENDING RIGHT NOW.  CHECK FOR THIS RECORD LOWER THAN FIRST REC.
      IF(XLAT .LE. XLAT1 ) GO TO 1000
C-----      WRITE(*,*)' ASAP_COPY:  PLACE 7'
      GO TO 4000
 3500 CONTINUE
C---	ASCENDING AT THE START OF THE FILE.
      IF(V(3) .LE. 0.0D0) GO TO 4000
C-----      WRITE(*,*)' ASAP_COPY:  PLACE 8'
C---	ASCENDING RIGHT NOW.  CHECK FOR THIS RECORD HIGHER THAN FIRST REC.
      IF(XLAT .GE. XLAT1 ) GO TO 1000
C-----      WRITE(*,*)' ASAP_COPY:  PLACE 9'
C
 4000 CONTINUE
C---	THIS IS NOT A RECORD 'R'.  WE CAN WRITE THIS RECORD.
C---	IF THIS TIME IS BEFORE THE OUTPUT START, SKIP TO THE NEXT RECORD.
      IF(T .LT. TFIRST ) GO TO 2000
C-----      WRITE(*,*)' ASAP_COPY:  PLACE 10'
C---	IF THIS TIME IS AFTER THE OUTPUT END TIME, GO TO THE FINISH.  
      IF(T .GT. TLAST ) GO TO 7000
C-----      WRITE(*,*)' ASAP_COPY:  PLACE 11'
      CALL VECROT(X,XROT,X1)
      CALL VECROT(V,XROT,V1)
C---	REV #:  ADD TO THE XR WHICH WAS READ FROM THE INPUT FILE.
      XR = XR + J
C---	LONGITUDE OF ASCENDING NODE, WRT VERNAL EQUINOX.  
      XLASC = XLASC + XROT
      XLASC = MOD(XLASC,360.0D0)
C---	SUBSAT LONGITUDE:  WESTWARD DRIFT. 
      XLON = XLON - DL
      XLON = MOD(XLON,360.0D0)
      IF(XLON .LT. 0.0D0) XLON = XLON + 360.0D0
      GHA = GHA + DGHA
      GHA = MOD(GHA,360.0D0)
C---	NOTE THE REV NUMBER FOR THE FIRST WRITE ONLY:  
      IF(IFIRSTW .EQ. 1) RFIRST = (XR + 0.5D0)
      IF(IFIRSTW .EQ. 1) IFIRSTW = 0
      WRITE (90) nodeflag, X1, V1, T, XR, XLASC, XLAT, XLON, GHA
      WRITE (99,*) nodeflag, X1, V1, T, XR, XLASC, XLAT, XLON, GHA
      NRECS = NRECS + 1
      RLAST = (XR + 0.49999999)
C---	DO THE NEXT RECORD.  
      GO TO 2000
 7000 CONTINUE
C---	THE JOB IS DONE; FINISH UP WITH THE FILES.  
      CLOSE(80,DISPOSE='DELETE')
      WRITE(*,*)' ASAP_COPY:  # RECS = ', NRECS
      RETURN
      END
********************************************************************
*  Name:	VECROT
c--port not needed *	COMPILE IN G_FLOATING
*	COMPILE IN G_FLOATING
*	COMPILE IN G_FLOATING
*  Module Type: SUBROUTINE 	Language: FORTRAN
*  $Logfile:   ACS003:[BLD.MPS.EPHM.SRC]ASAP_COPY.FOV  $
*  Purpose:	ROTATE A VECTOR ABOUT THE POSITIVE Z DIRECTION BY 
*		ADEG DEGREES.  
*  Functions called:
*  Input Parameters:
*  Name         Type    Definition
*  V(3)		REAL*8	INPUT VECTOR.
*  ADEG		REAL*8	AMOUNT TO ROTATE THE VECTOR ABOUT +Z AXIS.
*  Output Parameters:
*  Name         Type    Definition
*  VROT(3)	REAL*8	RESULT VECTOR.  
*  Variables:
*  Locals :
*  Externals :
*  Modification History:                                            
*  Date			Revision	Author
*  $Date$ $Revision$ $Author$
*                                                                   
*********************************************************************/
c-- port      OPTIONS /G_FLOATING
      SUBROUTINE VECROT (V,DEG,VROT)
      IMPLICIT NONE
      REAL*8 V(3), DEG, VROT(3)
      REAL*8 VXY(3), VXYP(3)
C---	COMPUTE VXY, VECTOR IN THE XY PLANE IN THE DIRECTION OF
C---	THE PROJECTION OF V.
      VXY(1) = V(1) 
      VXY(2) = V(2) 
C---	COMPUTE VXYP, VECTOR IN THE XY PLANE RESULTING FROM 
C---	ZUNIT X VXY.  THIS IS A VECTOR PERP TO VXYU, 90 DEG IN THE POSITIVE 
C---	DIRECTION.  
      VXYP(1) = - VXY(2) 
      VXYP(2) = VXY(1)
C---	O.K.  
C---	NOW THE RESULT VECTOR IS ( COS(DEG)*VXY + SIN(DEG)*VXYP)
C---
C---	THINK OF THE PROJECTION OF V DOWN TO THE XY PLANE AS THE X-AXIS
C---	AND THE PERPENDICULAR TO IT AS THE Y AXIS, THEN USE SIN AND COS OF DEG
C---	TO YIELD THE RESULT VECTOR.  
      VROT(1) = COSD(DEG) * VXY(1) + SIND(DEG) * VXYP(1)
      VROT(2) = COSD(DEG) * VXY(2) + SIND(DEG) * VXYP(2)
      VROT(3) = V(3)
      RETURN
      END
