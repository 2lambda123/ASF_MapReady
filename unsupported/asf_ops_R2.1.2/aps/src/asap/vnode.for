C--  Copyright (c)1996, California Institute of Technology.
C--  U.S. Government Sponsorship acknowledged.
C-- ==========================================================================
C--
C--  Fortran Filename:	vnode.for
C--
C--  Description:	
C--	
C--  Notes:
C--
C-- ==========================================================================

**************************************************************************
*  Name:  VNODE
C---	COMPILE THIS FILE IN G_FLOATING TO MATCH THE EPHEMERIS PROGRAM
* port:  not necessary to compile g_floating for Sun.
* port:  not necessary to compile g_floating for Sun.
*  Module Type: SUBROUTINE	Language: FORTRAN 
*  Purpose:
*	THIS ROUTINE COMPUTES A NODE VECTOR VN ANALYTICALLY, USING VECTOR CROSS 
*	PRODUCTS TO GET THE NODE VECTOR DIRECTION AND THE RELATIVE ANGULAR 
*	MOVEMENTS TO GET WEIGHTS TO USE WHEN MAKING WEIGHTED AVERAGE 
*	COMPUTATIONS.  
*	THE WEIGHTS ARE USED TO OBTAIN THE LONGITUDE OF ASCENDING NODE, WHICH
*	IS USED TO DERIVE THE X AND Y VALUES FOR THE UNIT NODE VECTOR.  THEN
*	THE WEIGHTS ARE USED TO DERIVE THE MAGNITUDE OF THE NODE VECTOR AND THE
*	OTHER VALUES.  
*	
*  Functions called: 
*  Input Parameters:
*  Name         Type    Definition
*  V1(12)	REAL	VECTOR V1.  IT CONTAINS R AND V IN CARTESIAN COORDS.
*			V1(1), V1(2), V1(3)	REAL*8	(X, Y, Z) POSITION
*			V1(4), V1(5), V1(6)	REAL*8	(X, Y, Z) VELOCITY
*			V1(7)			real*8	Ephemeris time in 
*						Julian days
*			V1(8)			real*8	rev number 
*			V1(9)			real*8	Long. of ascending node
*			V1(10)			real*8	Subsat lat, geocentric
*			V1(11)			real*8	Subsat lon, geocentric
*			V1(12)			real*8	Greenwich Hour Angle
*  V2(12)	REAL	VECTOR V2.  THE STRUCTURE IS THE SAME AS V1.
*  Output Parameters:
*  Name         Type    Definition
*  VN(12)	REAL	NODE VECTOR.  THE STRUCTURE IS THE SAME AS V1 AND V2.  
*  Variables:
*  Name         Type    Definition
*  Locals :
*  Externals :
*  Modification History:                                            
*  Date			Revision	Author
*  $Date$ $Revision$ $Author$
*                                                                   
*********************************************************************/
      SUBROUTINE VNODE(V1,V2,VN)

      character*100 SccsFileID
     -/'@(#)vnode.for	5.1 98/01/08 APS/ASF\0'/

      IMPLICIT NONE
      REAL*8 V1(12),V2(12),VN(12)
      CHARACTER*1 TYPE
      INTEGER J
      REAL*8 V1MAG, V2MAG, VNMAG, U1(3), U2(3), UN(3), XDUM, VEC(3)
      REAL*8 X12(3), COS12, COS1N, COSN2, ANG12, ANG1N, ANGN2, NORTH(3)
      REAL*8 F, W1, W2
C------- WRITE(*,*) ' @VNODE:  V1 = ', V1
C------- WRITE(*,*) '  VNODE:  V2 = ', V2
C---	DECIDE ON ASCENDING NODE OR DESCENDING NODE.
      TYPE = ' '
      IF(V1(3) .GT. 0.0D0) THEN
	IF(V2(3) .GT. 0.0D0) J = SQRT(-1.0D0)  !  CRASH THE PROGRAM.
	IF(V2(3) .LT. 0.0D0) THEN
C---		DESCENDING NODE.  
	   TYPE = 'D'
	ELSEIF (V2(3) .EQ. 0.0D0) THEN
C---		V2 IS A NODE ALREADY.  
		DO 1 J = 1, 12
		VN(J) = V2(J)
    1 CONTINUE
	ENDIF 
      ELSEIF (V1(3) .LT. 0.0D0) THEN
	IF(V2(3) .LT. 0.0D0) J = SQRT(-1.0D0)  !  CRASH THE PROGRAM.
	IF(V2(3) .GT. 0.0D0) THEN
C---		ASCENDING NODE.  
	   TYPE = 'A'
	ELSEIF (V2(3) .EQ. 0.0D0) THEN
C---		V2 IS A NODE ALREADY.  
		DO 2 J = 1, 12
		VN(J) = V2(J)
    2 CONTINUE
	ENDIF 
      ELSE 
C---	V1 IS A NODE ALREADY.  
	DO 3 J = 1, 12
	VN(J) = V1(J)
    3 CONTINUE
      ENDIF
      IF(TYPE .EQ. ' ') GO TO 9999
C---	CROSS PRODUCT
      CALL VX(V1,V2,X12)
C---	NORTH POLE UNIT VECTOR.  
      NORTH(1) = 0.0D0
      NORTH(2) = 0.0D0
      NORTH(3) = 1.0D0
C---	NORTH CROSS X12, A VECTOR IN THE DIRECTION OF THE ASCENDING NODE.  
      CALL VX(NORTH,X12,VEC)
C---	MAKE IT THE UNIT VECTOR:  THE UNII NODE VECTOR.  
      CALL UV(VEC,UN,XDUM)
C---	IF THIS IS A DESCENDING NODE, REVERSE THE VECTOR UN:
      IF(TYPE .EQ. 'D') THEN
	UN(1) = - UN(1)
	UN(2) = - UN(2)
	UN(3) = - UN(3)
      ENDIF
C---	MAKE THE UNIT VECTORS OF V1, V2
      CALL UV(V1,U1,V1MAG)
      CALL UV(V2,U2,V2MAG)
C---	THE ANGLE FROM U1 TO U2 = THE DOT PRODUCT BETWEEN U1 AND U2.
      COS12 = U1(1)*U2(1) + U1(2)*U2(2) + U1(3)*U2(3) 
      ANG12 = ACOS(COS12)
C---	THE ANGLE FROM U1 TO UN = THE DOT PRODUCT BETWEEN U1 AND UN.
      COS1N = U1(1)*UN(1) + U1(2)*UN(2) + U1(3)*UN(3) 
      ANG1N = ACOS(COS1N)
C---	THE ANGLE FROM UN TO U2 = THE DOT PRODUCT BETWEEN UN AND U2.
      COSN2 = UN(1)*U2(1) + UN(2)*U2(2) + UN(3)*U2(3) 
      ANGN2 = ACOS(COSN2)
C---	NOW USE THE ANGLES TO DETERMINE WEIGHTS FOR INTERPOLATION:  
      W1 = ANGN2 / ANG12
      W2 = 1.0D0 - W1
C---	NOW SET THE LONGITUDE OF ASCENDING NODE (DEG), WHICH MOVES VERY SLOWLY:
      CALL DINTRP_G(W1,W2,V1(9),V2(9),VN(9) )
C---	NOW SET THE MAGNITUDE OF THE NODAL VECTOR.  
      VNMAG = W1 * V1MAG  + W2 * V2MAG
C---	NOW SET THE NODAL VECTOR USING SIN AND COS (DEG) OF LONGITUDE OF 
C---	ASCENDING NODE:
      VN(1) = VNMAG * COSD(VN(9))
      VN(2) = VNMAG * SIND(VN(9))
      VN(3) = 0.0D0
C---	IF THIS IS A DESCENDING NODE, REVERSE THE VECTOR VN:
      IF(TYPE .EQ. 'D') THEN
	VN(1) = - VN(1)
	VN(2) = - VN(2)
	VN(3) = - VN(3)
      ENDIF
C---	NOW START TO GET THE VELOCITY VECTOR:  
C---	MAKE THE VELOCITY VECTORS INTO UNIT VECTORS:  
      CALL UV(V1(4),U1,V1MAG)
      CALL UV(V2(4),U2,V2MAG)
C---	COMPUTE DESIRED FRACTIONAL MOVEMENT FROM 1 TO THE NODE STATE:  
      F = ANG1N / ANG12
C---	OBTAIN UN, THE RESULT OF TRAVELING A THE FRACTION OF THE 
C---	DISTANCE FROM U1 TO U2:  
      CALL TRAVF(U1,U2,F,UN)
C---	COMPUTE DESIRED MAGNITUDE OF VELOCITY:  
C---	NOW USE THE PREVIOUS WEIGHTS COMPUTE THE MAGNITUDE OF THE VELOCITY
C---	VECTOR:  
      VNMAG = W1 * V1MAG + W2 * V2MAG 
C---	NOW SET THE VELOCITY VECTOR FOR THE NODAL STATE VECTOR:  
      VN(4) = UN(1) * VNMAG
      VN(5) = UN(2) * VNMAG
      VN(6) = UN(3) * VNMAG
C---	VECTORS NOW DONE; NOW SET THE LAST WORDS.  
C---	VN(7)	WEIGHTED AVERAGE Ephemeris time in Julian days
      VN(7) =  W1*V1(7)  + W2*V2(7)
C---	VN(8)	rev number - USE THE LATER REV.  
      VN(8) =  V2(8)
C---	VN(12)	Greenwich Hour Angle- DEGREE INTERPOLATION.  
C---	MAKE SURE IN THESE ANGLE CHANGES ONE ISN'T LIKE -179 AND THE OTHER +179
C---	AND THEREFORE ONLY 2 DEGREES APART.  WANT A RESULT BETWEEN THE TWO, 
C---	NOT A RESULT LIKE 0.  NEEDED FOR WORD 12.
      CALL DINTRP_G(W1,W2,V1(12),V2(12),VN(12) )
C---	VN(10)		Subsat lat, geocentric - AT NODE:  0.
      VN(10) = 0.0D0
C---	VN(11)		Subsat lon, geocentric - LONGITUDE RELATIVE TO THE 
C---						 PRIME MERIDIAN.  
      VN(11) = VN(9) - VN(12)
      IF(TYPE .EQ. 'D') VN(11) = VN(11) + 180.0D0
      IF(VN(11) .GE. 360.0D0) VN(11) = VN(11) - 360.0D0
      IF(VN(11) .LT. 0.0D0) VN(11) = VN(11) + 360.0D0
 9999 CONTINUE
C------- WRITE(*,*) ' $VNODE:  VN = ', VN
      RETURN
      END

      SUBROUTINE DINTRP_G(W1,W2,D1,D2,C )
C---	INTERPOLATION FOR DEGREES WHEN A AND B MIGHT STRADDLE A DISCONTINUITY 
C---	IN DEG.  SMALL MOVEMENTS ARE ASSUMED (.LT.180 DEG) AND MOVEMENT CAN 
C---	BE CLOCKWISE OR COUNTER CLOCKWISE, AS DEDUCED FROM THE SMALL MOVEMENT
C---	ASSUMPTION.  
C---	FOR SMALL ANGULAR MOVEMENTS ONLY.  
C---	FOR SMALL ANGULAR MOVEMENTS ONLY.  
C---	FOR SMALL ANGULAR MOVEMENTS ONLY.  
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      A = D1
      B = D2
C---C------- WRITE(*,*)' DINTRP_G:',W1,W2,A,B
      IF( ABS(A-B) .LE. 180.0) GO TO 7000
      IF ( A .LT. B ) GO TO 1000
      B = B + 360.0D0
      GO TO 7000
 1000 CONTINUE
      A = A + 360.0D0
 7000 CONTINUE
      C = W1*A + W2*B
      C = DMOD(C,360.0D0)
C---C------- WRITE(*,*)' DINTRP_G:',A,B,C
C---C------- WRITE(*,*)' '
      RETURN
      END

      SUBROUTINE UV(V,U,VMAG)
C---	V = INPUT VECTOR
C---	U = OUTPOUT UNIT VECTOR OF V
C---	VMAG = OUTPUT MAGNITUDE OF VECTOR V.  
      IMPLICIT NONE
      REAL*8 V(3), U(3), VMAG
C------- WRITE(*,*)' @UV:  V = ', V
      VMAG = V(1)**2 + V(2)**2 + V(3)**2 
      VMAG = SQRT(VMAG)
      U(1) = V(1) / VMAG
      U(2) = V(2) / VMAG
      U(3) = V(3) / VMAG
C------- WRITE(*,*)'  UV:  U = ', U
C------- WRITE(*,*)' $UV:  VMAG = ', VMAG
      RETURN
      END

      SUBROUTINE VX(V1,V2,X)
C---	V1, V2 ARE THE INPUT VECTORS.  
C---	X IS THE CROSS PRODUCT V1 x V2.  
      IMPLICIT NONE
      REAL*8 V1(3), V2(3), X(3)
      INTEGER J, K, L
C------- WRITE(*,*)' @VX:  V1 = ', V1
C------- WRITE(*,*)'  VX:  V2 = ', V2
      DO 1000 J = 1, 3
      K = J + 1
      L = J + 2
      IF(K .GT. 3) K = K - 3
      IF(L .GT. 3) L = L - 3
      X(J) = V1(K)*V2(L) - V1(L)*V2(K) 
 1000 CONTINUE
C------- WRITE(*,*)' $VX:  X = ', X
      RETURN
      END

      SUBROUTINE TRAVF(U1,U2,F,UF)
C---	INPUT UNIT VECTORS U1, U2, FRACTION F.
C---	OUTPUT UNIT VECTOR RESULTS FROM TRAVELLING A FRACTION F OF THE DISTANCE 
C---	FROM U1 TO U2 ON THE UNIT SPHERE.  
      IMPLICIT NONE
      REAL*8 U1(3), U2(3), F, UF(3), YMAG, UY(3), Z(3), Y(3), ANG12
      REAL*8 ANG1F
C------- WRITE(*,*)' @TRAVF:  U1 = ', U1
C------- WRITE(*,*)'  TRAVF:  U2 = ', U2
C------- WRITE(*,*)'  TRAVF:   F = ', F
C---	COMPUTE THE ANGLE FROM U1 TO U2.  
      ANG12 = ACOS( U1(1)*U2(1) + U1(2)*U2(2) + U1(3)*U2(3) )
C---	COMPUTE THE DESIRED ANGULAR MOVEMENT:
      ANG1F = ANG12 * F
C---	IN THE U1 U2 PLANE, PUT U1 ON THE X-AXIS, SO U1 IS THE X UNIT VECTOR.
C---	THE Y-AXIS WILL BE THE VECTOR 90 DEGREES AWAY FROM U1 ON THE WAY 
C---	FROM U1 TOWARDS U2.  
      CALL VX(U1,U2,Z)
      CALL VX(Z,U1,Y)
      CALL UV(Y,UY,YMAG)
C---	CONSTRUCT THE VECTOR UF VIA THE X AND Y AXES AND THE DESIRED ANGLE:
C---	UF = COS(ANG1F) * X  + SIN(ANG1F) * Y
C------- WRITE(*,*)'  TRAVF:  COS = ', COS(ANG1F)
C------- WRITE(*,*)'  TRAVF:  SIN = ', SIN(ANG1F)
      UF(1) = COS(ANG1F) * U1(1)  +  SIN(ANG1F) * UY(1)
      UF(2) = COS(ANG1F) * U1(2)  +  SIN(ANG1F) * UY(2)
      UF(3) = COS(ANG1F) * U1(3)  +  SIN(ANG1F) * UY(3)
C------- WRITE(*,*)' $TRAVF:  UF = ', UF
      RETURN
      END
**************************************************************************
*  Name:  VSTAT
*  $Logfile:   ACS003:[BLD.MPS.LIB.G_SRC]VNODE.FOV  $
*  Module Type: SUBROUTINE	Language: FORTRAN 
*  Purpose:
*	THIS ROUTINE COMPUTES A STATE VECTOR CORRESPONDING TO THE POINT IN TIME 
*	WHERE THE ACTION OF THE SATELLITE GOES FROM ASCENDING TO DESCENDING.  
*	VECTOR CROSS PRODUCTS ARE USED TO REACH THE VELOCITY VECTOR VSTAT AT 
*	THAT POINT.  THEN THE ANGULAR MOVEMENT BY THE VELOCITY VECTOR FROM THE 
*	FIRST VECTOR TO VSTAT AND THEN TO THE SECOND VECTOR IS USED TO DERIVE 
*	WEIGHTS TO USE WHEN MAKING WEIGHTED AVERAGE COMPUTATIONS.  
*	THE WEIGHTS ARE USED TO DERIVE THE MAGNITUDES OF THE POSITION VECTOR 
*	AND THE ANGULAR ROTATION OF THE POSITION VECTOR.  
*	
*  Functions called: 
*  Input Parameters:
*  Name         Type    Definition
*  V1(12)	REAL	VECTOR V1.  IT CONTAINS R AND V IN CARTESIAN COORDS.
*			V1(1), V1(2), V1(3)	REAL*8	(X, Y, Z) POSITION
*			V1(4), V1(5), V1(6)	REAL*8	(X, Y, Z) VELOCITY
*			V1(7)			real*8	Ephemeris time in 
*						Julian days
*			V1(8)			real*8	rev number 
*			V1(9)			real*8	Long. of ascending node
*			V1(10)			real*8	Subsat lat, geocentric
*			V1(11)			real*8	Subsat lon, geocentric
*			V1(12)			real*8	Greenwich Hour Angle
*  V2(12)	REAL	VECTOR V2.  THE STRUCTURE IS THE SAME AS V1.
*  Output Parameters:
*  Name         Type    Definition
*  VS(12)	REAL	STATIONARY STATE VECTOR.  THE SATELLITE IS NEITHER 
*			ASCENDING NOR DESCENDING.  
*  Variables:
*  Name         Type    Definition
*  Locals :
*  Externals :
*  Modification History:                                            
*  Date			Revision	Author
*  $Date$ $Revision$ $Author$
*                                                                   
*********************************************************************/
      SUBROUTINE VSTAT(V1,V2,VS)
      IMPLICIT NONE
      REAL*8 V1(12),V2(12),VS(12)
      CHARACTER*1 TYPE
      INTEGER J
      REAL*8 V1MAG, V2MAG, VSMAG, U1(3), U2(3), US(3), XDUM, VEC(3)
      REAL*8 X12(3), COS12, COS1N, COSN2, ANG12, ANG1N, ANGN2, NORTH(3)
      REAL*8 W1, W2, LASC, YREF(3), ANGN1, ANGNS
      REAL*8 H(3), HNDOT, INCL1, INCL2, INCL, ANODE(3)
C---      WRITE(*,*) ' @VSTAT:  V1 = ', V1
C---      WRITE(*,*) '  VSTAT:  V2 = ', V2
C---	DECIDE ON ASCENDING START OR DESCENDING START.
      TYPE = ' '
      IF(V1(6) .GT. 0.0D0) THEN
	IF(V2(6) .GT. 0.0D0) J = SQRT(-1.0D0)  !  CRASH THE PROGRAM.
	IF(V2(6) .LT. 0.0D0) THEN
C---		ASCENDING START.
	   TYPE = 'A'
	ELSEIF (V2(6) .EQ. 0.0D0) THEN
C---		V2 IS STATIONARY ALREADY.  
		DO 1 J = 1, 12
		VS(J) = V2(J)
    1 CONTINUE
	ENDIF 
      ELSEIF (V1(6) .LT. 0.0D0) THEN
	IF(V2(6) .LT. 0.0D0) J = SQRT(-1.0D0)  !  CRASH THE PROGRAM.
	IF(V2(6) .GT. 0.0D0) THEN
C---		DESCENDING START.
	   TYPE = 'D'
	ELSEIF (V2(6) .EQ. 0.0D0) THEN
C---		V2 IS STATIONARY ALREADY.  
		DO 2 J = 1, 12
		VS(J) = V2(J)
    2 CONTINUE
	ENDIF 
      ELSE 
C---	V1 IS STATIONARY ALREADY.  
	DO 3 J = 1, 12
	VS(J) = V1(J)
    3 CONTINUE
      ENDIF
      IF(TYPE .EQ. ' ') GO TO 9999
C---	CROSS PRODUCT
      CALL VX(V1(4),V2(4),X12)
C---	NORTH POLE UNIT VECTOR.  
      NORTH(1) = 0.0D0
      NORTH(2) = 0.0D0
      NORTH(3) = 1.0D0
C---	NORTH CROSS X12, A VECTOR IN VELOCITY1 AND VELOCITY2 PLANES AND IN THE
C---	Z=0 PLANE;
      CALL VX(NORTH,X12,VEC)
C---	MAKE IT A UNIT VECTOR
      CALL UV(VEC,US,XDUM)
C---	IF THIS IS AN ASCENDING START, REVERSE THE VECTOR US:
      IF(TYPE .EQ. 'A') THEN
	US(1) = - US(1)
	US(2) = - US(2)
	US(3) = - US(3)
      ENDIF
C---	NOW US IS BETWEEN V1 AND V2.  
C---	MAKE THE UNIT VELOCITY VECTORS OF V1, V2
      CALL UV(V1(4),U1,V1MAG)
      CALL UV(V2(4),U2,V2MAG)
C---	THE ANGLE FROM U1 TO U2 = THE DOT PRODUCT BETWEEN U1 AND U2 VELOCITIES.
      COS12 = U1(1)*U2(1) + U1(2)*U2(2) + U1(3)*U2(3) 
      ANG12 = ACOS(COS12)
C---	THE ANGLE FROM U1 TO US = THE DOT PRODUCT BETWEEN U1 AND US.
      COS1N = U1(1)*US(1) + U1(2)*US(2) + U1(3)*US(3) 
      ANG1N = ACOS(COS1N)
C---	THE ANGLE FROM US TO U2 = THE DOT PRODUCT BETWEEN US AND U2.
      COSN2 = US(1)*U2(1) + US(2)*U2(2) + US(3)*U2(3) 
      ANGN2 = ACOS(COSN2)
C---	NOW USE THE ANGLES AS WEIGHTS TO COMPUTE THE MAGNITUDE OF THE VECTORS:  
      W1 = ANGN2 / ANG12
      W2 = 1.0D0 - W1
C---      WRITE(*,*)'  VSTAT:  W1 = ', W1, '  W2 = ', W2
C=====	END OF STEP 1.  NOW USE THE WEIGHTS TO BUILD OSCULATING ORBITAL 
C---	ELEMENTS BY WEIGHTED INTERPOLATION FROM THE OSCULATING ORBITAL ELEMENTS 
C---	OF THE TWO STATE VECTORS.  THEN BUILD R, V FROM THEM.  
C
C---	NOW DETERMINE THE LONGITUDE OF ASCENDING NODE (DEGREES) BY WEIGHTED 
C---	INTERPOLATION:
      CALL DINTRP_G(W1,W2,V1(9),V2(9),LASC )
      VS(9)  = LASC
C---	NOW THE DESIRED VELOCITY AT THE "STATIONARY" POINT WILL BE OPPOSITE 
C---	THE DIRECTION OF THE ASCENDING NODE IF WE HAVE AN ASCENDING START; 
C---	ALONG THE DIRECTION OF THE ASCENDING NODE IF WE HAVE A DESCENDING START.
C---	NOW DETERMINE THE ASCENDING NODE UNIT VECTOR:  
C---	LASC IS IN DEGREES:
      ANODE(1) = COSD(LASC)
      ANODE(2) = SIND(LASC)
      ANODE(3) = 0.0D0
C---	NOW DETERMINE THE MAGNITUDE OF THE VELOCITY BY WEIGHTED INTERPOLATION:
      VSMAG = W1*V1MAG + W2*V2MAG
C---	NOW OBTAIN THE DESIRED VELOCITY OPPOSITE THE NODE VECTOR:
      VS(4) = - ANODE(1) * VSMAG
      VS(5) = - ANODE(2) * VSMAG
      VS(6) = - ANODE(3) * VSMAG
C---	NOW CHECK FOR DESCENDING START:  
      IF(TYPE .EQ. 'D') THEN
	VS(4) = - VS(4)
	VS(5) = - VS(5)
	VS(6) = - VS(6)
      ENDIF 
C---	VELOCITY IS DONE.  
C---	NOW DETERMINE THE INCLINATION.  FIRST GET THE 2 INCLINATIONS:  
C---	H:  ANGULAR MOMENTUM UNIT VECTOR:  RxV
      CALL VX(V1,V1(4),VEC)
      CALL UV(VEC,H,XDUM)
C---	INCLINATION:  H <dot> NORTH = COS(i).  
      HNDOT = H(1)*NORTH(1) + H(2)*NORTH(2) + H(3)*NORTH(3) 
C---	INCLINATION OF V1:  DEGREES
      INCL1 = ACOSD(HNDOT)
      WRITE(*,*)'  VSTAT:  INCL1 = ', INCL1
      CALL VX(V2,V2(4),VEC)
      CALL UV(VEC,H,XDUM)
      HNDOT = H(1)*NORTH(1) + H(2)*NORTH(2) + H(3)*NORTH(3) 
C---	INCLINATION OF V2:  DEGREES
      INCL2 = ACOSD(HNDOT)
      WRITE(*,*)'  VSTAT:  INCL2 = ', INCL2
C---	NOW DETERMINE THE INCLINATION OF THE STATIONARY STATE BY WEIGHTED 
C---	INTERPOLATION.  
      INCL = W1*INCL1 + W2*INCL2
      WRITE(*,*)'  VSTAT:  INCL = ', INCL
C---	USING i, LASC, DETERMINE THE STATIONARY UNIT VECTOR OF ANGULAR MOMENTUM.
C---	LASC IS IN DEGREES.  ALSO INCL:
      H(1) = COSD(LASC - 90.0D0) * SIND(INCL)
      H(2) = SIND(LASC - 90.0D0) * SIND(INCL)
C---	INCL IS IN DEGREES
      H(3) = COSD(INCL)
C---	COMPUTE ASCENDING NODE UNIT VECTOR:  
      ANODE(1) = COSD(LASC)
      ANODE(2) = SIND(LASC)
      ANODE(3) = 0.0D0
C---	COMPUTE YREF, THE UNIT VECTOR H x ANODE:
      CALL VX(H,ANODE,VEC)
C---      WRITE(*,*)'  VSTAT:  H = ', H
C---      WRITE(*,*)'  VSTAT:  ANODE = ', ANODE
      CALL UV(VEC,YREF,XDUM)
C---      WRITE(*,*)'  VSTAT:  YREF = ', YREF
C---	NOW COMPUTE THE ANGLE BETWEEN THE NODE AND V1:
      CALL UV(V1,VEC,V1MAG)
      ANGN1=ACOSD(ANODE(1)*VEC(1) + ANODE(2)*VEC(2) + ANODE(3)*VEC(3))
C---	NOW COMPUTE THE ANGLE BETWEEN THE NODE AND V2:
      CALL UV(V2,VEC,V2MAG)
      ANGN2=ACOSD(ANODE(1)*VEC(1) + ANODE(2)*VEC(2) + ANODE(3)*VEC(3))
C---	NOW COMPUTE THE ANGLE BETWEEN THE NODE AND VS VIA WEIGHTED INTERP:
      CALL DINTRP_G(W1,W2,ANGN1,ANGN2,ANGNS)
C---      WRITE(*,*)'  VSTAT:  ANGN1 = ', ANGN1
C---      WRITE(*,*)'  VSTAT:  ANGN2 = ', ANGN2
C---      WRITE(*,*)'  VSTAT:  ANGNS = ', ANGNS
C---	NOW COMPUTE THE STATIONARY POSITION UNIT VECTOR VIA ANODE AND YREF.  
C---	THINK OF ANODE AS THE X-AXIS IN THE PLANE PERPINDICULAR TO H, 
C---	AND THINK OF YREF AS THE Y-AXIS IN THAT PLANE:
C---	VS = COSD(ANGNS)*ANODE + SIND(ANGNS)*YREF
      US(1) = COSD(ANGNS)*ANODE(1) + SIND(ANGNS)*YREF(1)
      US(2) = COSD(ANGNS)*ANODE(2) + SIND(ANGNS)*YREF(2)
      US(3) = COSD(ANGNS)*ANODE(3) + SIND(ANGNS)*YREF(3)
C---	NOW DETERMINE THE MAGNITUDE OF THE POSITION VECTOR BY WEIGHTED 
C---	INTERPOLATION:
      VSMAG = W1*V1MAG + W2*V2MAG
C---	NOW CHECK FOR DESCENDING START:  
      IF(TYPE .EQ. 'D') THEN
C---      WRITE(*,*)' DESCENDING TYPE'
	US(1) = - US(1)
	US(2) = - US(2)
	US(3) = - US(3)
      ENDIF 
C---	NOW COMPUTE THE POSITION VECTOR:  
      VS(1) = US(1) * VSMAG
      VS(2) = US(2) * VSMAG
      VS(3) = US(3) * VSMAG
C---	VECTORS NOW DONE; NOW SET THE LAST WORDS.  
C---	VS(7)	WEIGHTED AVERAGE Ephemeris time in Julian days
      VS(7) =  W1*V1(7)  + W2*V2(7)
C---	VS(8)	rev number - USE THE LATER REV.  
      VS(8) =  V2(8)
C---	VS(12)	Greenwich Hour Angle- DEGREE INTERPOLATION.  
C---	MAKE SURE IN THESE ANGLE CHANGES ONE ISN'T LIKE -179 AND THE OTHER +179
C---	AND THEREFORE ONLY 2 DEGREES APART.  WANT A RESULT BETWEEN THE TWO, 
C---	NOT A RESULT LIKE 0.  NEEDED FOR WORD 12.
C---      WRITE(*,*)'  VSTAT:  W1,W2,V1(12), V2(12), VS(12) = '
      CALL DINTRP_G(W1,W2,V1(12),V2(12),VS(12) )
C---      WRITE(*,*)   W1,W2,V1(12), V2(12), VS(12) 
C---	VS(10)		Subsat lat, geocentric - ASIN(Z VALUE OF UNIT VECTOR.)
C---	DEGREES.
      VS(10) = ASIND(US(3))
C---	VS(11)		Subsat lon, geocentric - LONGITUDE RELATIVE TO THE 
C---						 PRIME MERIDIAN.  
C---      WRITE(*,*)'  VSTAT:  US = ', US
      VS(11) = ATAN2D(US(2),US(1)) - VS(12)
      IF(VS(11) .LT. 0.0D0) VS(11) = VS(11) + 360.0D0
      IF(VS(11) .LT. 0.0D0) VS(11) = VS(11) + 360.0D0
 9999 CONTINUE
C---      WRITE(*,*) ' $VSTAT:  VS = ', VS
      RETURN
      END
