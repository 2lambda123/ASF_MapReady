C--  Copyright (c)1996, California Institute of Technology.
C--  U.S. Government Sponsorship acknowledged.

********************************************************************
*  Name:	SSCVQ
*  Module Type: SUBROUTINE 	Language:  FORTRAN
*  $Logfile:   QDISK:[BLD.MPS.LIB.SRC]SSCVQ.QFV  $
*  Purpose:	RUN SPECIFIC SITE COVERAGE FOR A QUADRILATERAL SITE WITH A 
*		TIME - BASED QUERY.  
*  Functions called:
*  VECTOR LIBRARY:  SPHERE
*  Input Parameters:
*  Name         Type    Definition
*  dbproc       INT*4   pointer to the Sybase info structure.
*  IBATCH	INT*4	BATCH FLAG:  =0: INTERACTIVE; =1: BATCH
*  DARID	INT*4	ID OF DAR
*  SITENAME	CHAR*32	NAME OF SITE
*  NWLAT	REAL*8	LATITUDE IN DEGREES OF POINT 1
*  NWLON	REAL*8	LONGITUDE IN DEGREES OF POINT 1
*  NELAT	REAL*8	LATITUDE IN DEGREES OF POINT 2
*  NELON	REAL*8	LONGITUDE IN DEGREES OF POINT 2
*  SELAT	REAL*8	LATITUDE IN DEGREES OF POINT 3
*  SELON	REAL*8	LONGITUDE IN DEGREES OF POINT 3
*  SWLAT	REAL*8	LATITUDE IN DEGREES OF POINT 4
*  SWLON	REAL*8	LONGITUDE IN DEGREES OF POINT 4
*  SAT		CHAR*2	SATELLITE NAME
*  SENSOR	CHAR*3	SENSOR
*  ASCDSC	CHAR*1	ASCENDING/DESCENDING FLAG
*  TIME1	REAL*8	TIME AT START OF ANALYSIS PERIOD
*  TIME2	REAL*8	TIME AT END OF ANALYSIS PERIOD
*  TREV1	INT	REV AT START OF ANALYSIS PERIOD
*  TREV2	INT	REV AT END OF ANALYSIS PERIOD
*  Output Parameters:
*  Name         Type    Definition
*  NRECS	INTEGER	IF ISTAT = 0, NUMBER OF RECORDS APPENDED.  
*  ISTAT	INTEGER	0 IF NO ERRORS, 1 OTHERWISE.  
*  Variables:
*  Locals :
*  Externals :
*
*  Modification History:                                            
*  Date			 Rev  Author
*  18 Jul 1990 16:52:36  2.0  DBMAN  
*  11 Mar 1993 13:37:44  2.1  IBBOTT  
*  $Date$ $Revision$ $Author$
*********************************************************************/
      SUBROUTINE SSCVQ (dbproc, IBATCH,DARID,SITENAME,
     ?	NWLAT,NWLON,NELAT,NELON,SELAT,SELON,SWLAT,SWLON,
     ?	  SAT,SENSOR,ASCDSC,TIME1,TIME2,TREV1,TREV2,NRECS,ISTAT )
      character*100 SccsFileID
     -/'@(#)sscvq.for	5.1 98/01/08 APS/ASF\0'/

      IMPLICIT NONE
      INCLUDE 'APS_HOME:include/local/timeconv.inc'
      INTEGER DARID, NRECS, ISTAT, IBATCH, TREV1, TREV2
      REAL*8 TIME1, TIME2
      CHARACTER*33  SITENAME
      CHARACTER*3   SAT
      CHARACTER*4   SENSOR
      CHARACTER*2   ASCDSC
      REAL*8 NWLAT,NWLON,NELAT,NELON,SELAT,SELON,SWLAT,SWLON
      CHARACTER*1 OLDASCDSC, CASCDSC, I_ASCDSC
      CHARACTER*22 ASFTIME1, ASFTIME2
      REAL*8 XLL(2),ANGRAD,Q1(3),Q2(3),Q3(3),Q4(3)
      REAL*8 SUBLAT,SUBLON,NRLAT,NRLON,FARLAT,FARLON
      REAL*8 ETIME,OLDETIME,NLAT,SLAT,ELON,WLON 
      REAL*8 GROUND1(2), NEAR1(2), FAR1(2)
      REAL*8 GROUND2(2), NEAR2(2), FAR2(2)
      INTEGER IREV, OLDREV, COVRECS, J, IBRKUP
      REAL*8 PDIST, SWATH, BUF(3)
      REAL*8 RADSEARCH
      INTEGER NPOINT,ILOOK,INORML,IEOF
      REAL*8 POINT(10,99)
      REAL*8 START(10), STOP(10)

      integer*4 p_rec, p_first, p_next, n_insert
      real*8 satalt, sunang
      integer opermode
      character*2 sunflag, crossflag
      character*4 station_id
      character*5 masks
      integer rcode, system, lastc
      integer print_flag
 
c---    STATEMENTS TO SUPPORT SYBASE CALLS TO DBLIB
      integer*4 dbproc
c---    pass dbproc by value to C routines:
      external insert_sscvrg    !$pragma c(insert_sscvrg)
      external retrieve_cvrg    !$pragma c(retrieve_cvrg)
      external dbexit           !$pragma c(dbexit)
c---    STATEMENTS TO SUPPORT SYBASE CALLS TO DBLIB
      external get_cvrg         !$pragma c(get_cvrg)
 
C*  POINT(10,*)	REAL*8	SWATH POINTS:  
C*			POINT(1,J) =  EPHEMERIS TIME OF POINT J
C*			POINT(2,J) =  GROUND TRACK X AT TIME J
C*			POINT(3,J) =  GROUND TRACK Y AT TIME J
C*			POINT(4,J) =  GROUND TRACK Z AT TIME J
C*			POINT(5,J) =  SWATH LEFT POINT X AT TIME J
C*			POINT(6,J) =  SWATH LEFT POINT Y AT TIME J
C*			POINT(7,J) =  SWATH LEFT POINT Z AT TIME J
C*			POINT(8,J) =  SWATH RIGHT POINT X AT TIME J
C*			POINT(9,J) =  SWATH RIGHT POINT Y AT TIME J
C*			POINT(10,J) = SWATH RIGHT POINT Z AT TIME J
C*		THE LEFT AND RIGHT ORIENTAION IS AS IF YOU ARE IN THE MIDDLE
C*		OF THE SWATH AND FACING IN THE DIRECTION OF MOTION.  
C*  NPOINT	INTEGER	NUMBER OF POINTS IN ARRAY POINT
C*  Output Parameters:
C*  Name         Type    Definition
C*  START(10)	REAL*8	INFORMATION AT START OF SWATH COVERAGE OF CIRCLE
C*			SAME STRUCTURE AS IN POINTS.  
C*			IF NO COVERAGE FOR SITE, ALL VALUES ARE 0.0D00 
C*  STOP(10)	REAL*8	INFORMATION AT END OF SWATH COVERAGE.
C*			SAME STRUCTURE AS IN POINTS.  
C*			IF NO COVERAGE FOR SITE, ALL VALUES ARE 0.0D00 
C---	This call is EITHER ascending OR descending:  

      print_flag = 1

      if(print_flag .eq. 1) then
        print 8001,dbproc, IBATCH, DARID, SITENAME(1:lastc(SITENAME)),
     ?		NWLAT,NWLON,NELAT,NELON,SELAT,SELON,SWLAT,SWLON,
     ?          SAT(1:2), SENSOR(1:3), ASCDSC(1:1), TIME1, TIME2,
     ?          TREV1, TREV2
 8001   format(' sscvq.for:  dbproc = ', Z8,
     ?          /13x,' IBATCH = ', I,
     ?          /13x,' DARID = ', I, /13x,' SITENAME = ', A,
     ?		/13x,' NWLAT/NWLON =', F8.3,' / ', F8.3,
     ?		/13x,' NELAT/NELON =', F8.3,' / ', F8.3,
     ?		/13x,' SELAT/SELON =', F8.3,' / ', F8.3,
     ?		/13x,' SWLAT/SWLON =', F8.3,' / ', F8.3,
     ?          /13x,'SAT = ', A, '  SENSOR = ', A, '  ASCDSC = ', A
     ?          /13x,'TIME1 = ', F18.9, /13x,'TIME2 = ', F18.9,
     ?          /13x,'TREV1 = ', I, /13x,'TREV2 = ', I)
      endif
 

C---    This call is EITHER ascending OR descending:
 
      IF(ASCDSC(1:1) .NE. 'A' .AND. ASCDSC(1:1) .NE. 'D') then
        print *,'sscvq.for:  ASCDSC parameter must be "A" or "D".'
        print *,'            terminating this run.'
        rcode = system('banner ERROR' // char(0))
        call exit(101)
      endif

C---	INITIALIZE
      IBRKUP = 0
      NPOINT = 0
      NRECS = 0
      ILOOK = 0
C---	ILOOK IS A FLAG:  	= 2	LEFT LOOKING SENSOR
C---				= 1	RIGHT LOOKING
C---				= 0	DON'T KNOW YET; RIGHT LOOKING ASSUMED
C--	THIS FLAG IS USED TO SUPPLY THE GEOMETRICAL ROUTINE WITH THE NECESSARY
C---	LEFT AND RIGHT SIDE OF THE SWATH INFO.  
C---	CHECK FOR TARGET AREA STRADDLING THE DATE LINE.  IF SO, 
C---	THE QUERY CHANGES.  

      ISTAT = 0

C---	CONVERT INPUT POINTS TO XYZ ON THE UNIT CIRCLE.
      XLL(1) = NWLAT
      XLL(2) = NWLON
      CALL LL2XYZ(XLL,Q1)
      XLL(1) = NELAT
      XLL(2) = NELON
      CALL LL2XYZ(XLL,Q2)
      XLL(1) = SELAT
      XLL(2) = SELON
      CALL LL2XYZ(XLL,Q3)
      XLL(1) = SWLAT
      XLL(2) = SWLON
      CALL LL2XYZ(XLL,Q4)

C---	DETERMINE MIN/MAX LAT AND LON QUERY PARAMETERS. 
C---	WANT TO GET A COVERAGE POINT BEFORE AND AFTER THE AREA.  
C---	PDIST IS THE AVERAGE DISTANCE BETWEEN POINTS + 10 PERCENT.
      PDIST = 440.0D0 
      SWATH = 100.0D0
C---	J-ERS-1, 1 MINUTE INTERVALS MEANS POINTS ABOUT 420 KM APART.
      IF(SAT.EQ.'J1' ) PDIST = 470.0D0
C---	ADD SWATH WIDTH.  
      RADSEARCH = PDIST + SWATH
C---	NOW CONVERT TO DEGREES.  
      RADSEARCH = (RADSEARCH / 1.852D0) / 60.0D0
C---	NOW BUILD TARGET AREA.  MIN/MAX LAT/LON
      CALL SSCVQB(NWLAT,NWLON,NELAT,NELON,SELAT,SELON,SWLAT,SWLON,
     ?		RADSEARCH,NLAT,SLAT,ELON,WLON,INORML )

 
      call retrieve_cvrg(%VAL(dbproc), SAT, SENSOR, TREV1, TREV2,
     ?          TIME1, TIME2, ASCDSC, NLAT, SLAT, ELON, WLON,
     ?          INORML, COVRECS, p_first)
 
      p_rec = p_first
 
      IF(COVRECS.GT.0) GO TO 3100

C---	NO RECORDS RETRIEVED.  
      WRITE(*,*)'SSCVQ:  No relevant coverage records found.'
      GO TO 9000
 3100 CONTINUE
C---	ALL THE COVERAGE RECORDS WERE WRITTEN.  NOW READ THEM AND APPEND
C---	SPECIFIC SITE COVERAGE RECORDS AS DEVELOPED.  
      IEOF = 0
      OLDETIME = 0.0D0
      ILOOK = 0
      J = 0
 4000 CONTINUE
C---    READ THE NEXT COVERAGE RECORD FROM THE linked list.
c---    p_rec is a pointer to a structure with the desired data.
c---    it is zeroed out by get_cvrg when it frees the memory.
 
c--port-      READ(97,ERR=8004,IOSTAT=IOS,END=5000)
c--port-     ?          ETIME,IREV,SUBLAT,SUBLON,NRLAT,NRLON,
c--port-     ?                  FARLAT, FARLON, CASCDSC
 
c---    p_rec is an "end of file" indicator.  if = 0, no more recs.
 
      if(p_rec .ne. 0) then
 
c       not EOF
        call get_cvrg(p_rec, p_next, SAT, SENSOR, ETIME, IREV,
     ?          SUBLAT, SUBLON, NRLAT, NRLON, FARLAT, FARLON,
     ?          satalt, sunflag, sunang, station_id, masks, opermode,
     ?          crossflag, CASCDSC)
c---    set up for the next get coverage.
        p_rec = p_next
 
      else
 
c       eof; no more records to be obtained.
C---	EOF:  FORCE PROCESSING OF THE CURRENT GROUP 
C---	AND THEN LEAVE THE LOOP VIA FLAG.  
      	IEOF = 1
      	IF(NPOINT.LE.1) GO TO 9000
      	GO TO 6100

      endif
 
c---    not EOF yet.
C---	IS THIS RECORD A PART OF THE CURRENT GROUP?  IF NOT, THEN PROCESS
C---	THE GROUP WE HAVE JUST ACCUMULATED.  
C---	CHECK FOR FIRST TIME THROUGH.  
      IF(NPOINT.LE.0) GO TO 7000
C---	NOW CHECK TO SEE IF THIS COVERAGE IS TOO CLOSE IN TIME TO THE PREVIOUS
C---	POINT FOR THE SUCCESSIVE COVERAGE POINTS TO BE PERCEIVED AS SEPARATE.  
C---	REMEMBER THAT THE LAT/LONS ARE STORED IN THE DB AS F4.  
C---	USING .02 SECONDS AS THE CRITERION.  
      IF(ETIME - OLDETIME .LT. 2.3D-7) GO TO 4000
C---	CHECK TO SEE IF THIS RECORD IS PART OF THE CURRENT GROUP AND IT 
C---	BELONGS TO A DIFFERENT REV:  
      IF(ETIME-OLDETIME .GE. 1.0D-3 .OR. IREV .LE. OLDREV)GO TO 6090
C---		THIS RECORD STARTS A NEW REV AND IT BELONGS TO THE 
C---		CURRENT GROUP IN TERMS OF TIME PROXIMITY.  
C---		BECAUSE OF VARIOUS CONVENTIONS, THE COVERAGE MUST BE 
C---		BROKEN UP HERE, AT THE CHANGEOVER FROM ONE REV TO THE NEXT.
C---		SO:
C---		1) THE CURRENT RECORD WILL BE PUT ON THE POINT ARRAY
C---		2) THE SPECIFIC SITE COVERAGE ROUTINE WILL BE CALLED.
C---		3) THE POINT ARRAY WILL BE ZEROED
C---		4) THE CURRENT RECORD WILL AGAIN BE PUT ON THE POINT ARRAY, 
C---		   STARTING THE NEXT GROUP.  
C---		NOW PUT THE CURRENT RECORD ON THE POINT ARRAY:
C---	VERY SORRY:  THIS IS KLUGEY.  IT IS A PATCH.  
      IBRKUP = 1
C---	NOW PUT THE RECORD ON THE ARRAY, (AND DO OTHER STUFF IF NEEDED) 
C---	THEN COME BACK HERE (6050).  (THE IBRKUP=1 FLAG GETS US BACK HERE.  
      GO TO 7000
 6050 CONTINUE
C---	O.K. NOW WE ARE BACK FROM PUTTING THE DATA ON THE NPOINT ARRAY.  
      IBRKUP = 0
C---	NOW FORCE THE CALL TO THE SPECIFIC SITE COVERAGE ROUTINE.  
C---	AFTER THAT, WE ARE BACK TO NORMAL.  THE CURRENT RECORD WILL BE PLACED
C---	AUTOMATICALLY.  
      GO TO 6100
 6090 CONTINUE
C---	WE CHECK FOR PART OF CURRENT GROUP BY COMPARING THE CURRENT TIME
C---	WITH THE MOST RECENT TIME.  
      IF(ETIME - OLDETIME .LT. 1.0D-3) GO TO 7000
C---	NOT PART OF THE CURRENT GROUP.  
 6100 CONTINUE
C---	CHECK FOR ONE POINT:
      IF(NPOINT .GT. 1) GO TO 6110
C---	ONLY ONE POINT; NO COVERAGE.  
      NPOINT = 0
      GO TO 7000
 6110 CONTINUE
C---	MUST PROCESS THE GROUP AND SEE IF THIS COVERAGE PERIOD COVERS THE SITE.
      CALL SSCOVQ(Q1,Q2,Q3,Q4,POINT,NPOINT,START,STOP,I_ASCDSC)
C---	NOW RESET THE POINTER; THIS GROUP IS FINISHED.  
      NPOINT = 0
      IF(START(1).EQ.0.0D0) GO TO 7000
C---	NOW WRITE THE SSCVRG RECORD FROM START AND STOP TO A FILE.  
C---	THERE WAS COVERAGE FROM THIS GROUP.  
C---	DEVELOP ASFTIME.
C---      CALL ET2ASF(START(1),ASFTIME1)
      rcode = tc_et2asf(%VAL(START(1)),ASFTIME1)
C---      CALL ET2ASF(STOP(1),ASFTIME2)
      rcode = tc_et2asf(%VAL(STOP(1)),ASFTIME2)
C---	DEVELOP START LAT, STOP LAT.
      CALL XYZ2LL(START(2),GROUND1)
      CALL XYZ2LL(STOP(2),GROUND2)
      IF(ILOOK .EQ. 2) GO TO 6500
C---	RIGHT LOOKING SWATH.  
C---	DEVELOP NEAR AND FAR POINTS.
      CALL XYZ2LL(START(5),NEAR1)
      CALL XYZ2LL(STOP(5),NEAR2)
      CALL XYZ2LL(START(8),FAR1)
      CALL XYZ2LL(STOP(8),FAR2)
      GO TO 6600
 6500 CONTINUE
C---	LEFT LOOKING SWATH.  
C---	DEVELOP NEAR AND FAR POINTS.
      CALL XYZ2LL(START(8),NEAR1)
      CALL XYZ2LL(STOP(8),NEAR2)
      CALL XYZ2LL(START(5),FAR1)
      CALL XYZ2LL(STOP(5),FAR2)
 6600 CONTINUE
C---	NOW APPEND RECORD TO THE DATABASE.  
      NRECS = NRECS + 1
C---    NOW APPEND.  USE ASCENDING / DESCENDING FLAG FROM THE CALL PARAMETER.
      call insert_sscvrg(%VAL(dbproc), DARID, 
     ?   SITENAME(1:lastc(SITENAME)) // char(0), SAT, SENSOR,
     ?   OLDREV, ASFTIME1, ASFTIME2, START(1), STOP(1),
     ?   GROUND1(1), GROUND2(1), NEAR1(1), NEAR1(2), FAR1(1), FAR1(2),
     ?   NEAR2(1), NEAR2(2), FAR2(1), FAR2(2), ASCDSC, n_insert )
 
      IF(IEOF .EQ. 1) GO TO 9000
C---	STILL POSSIBLY MORE RECORDS TO READ.  
 7000 CONTINUE
C---	NOW ADD THE CURRENT RECORD'S DATA TO THE POINT ARRAY.  
C---	CHECK IF WE NEVER GOT A RECORD BECAUSE OF EOF.  
      IF(IEOF .EQ. 1) GO TO 9000
      IF(IBRKUP .EQ. 0) OLDREV = IREV
      OLDETIME = ETIME
      OLDASCDSC = CASCDSC
C---	ADD THIS RECORD ON TO THE END OF THE POINT ARRAY.  
      NPOINT = NPOINT + 1
      POINT(1,NPOINT) = ETIME
C---	DEVELOP SUBSAT POINT XYZ.  
      XLL(1) = SUBLAT
      XLL(2) = SUBLON
      CALL LL2XYZ(XLL,POINT(2,NPOINT))
C---	CHECK FOR RIGHT OR LEFT LOOKING SWATH.  
C---	DEVELOP LEFT AND RIGHT SWATH ENDPOINT XYZ'S.  
      IF(ILOOK .EQ. 2 ) GO TO 7050
C---	RIGHT LOOKING OR WE ASSUME RIGHT FOR NOW.  
      XLL(1) = NRLAT
      XLL(2) = NRLON
      CALL LL2XYZ(XLL,POINT(5,NPOINT))
      XLL(1) = FARLAT
      XLL(2) = FARLON
      CALL LL2XYZ(XLL,POINT(8,NPOINT))
      GO TO 7100
 7050 CONTINUE
C---	LEFT LOOKING SWATH.  
      XLL(1) = NRLAT
      XLL(2) = NRLON
      CALL LL2XYZ(XLL,POINT(8,NPOINT))
      XLL(1) = FARLAT
      XLL(2) = FARLON
      CALL LL2XYZ(XLL,POINT(5,NPOINT))
 7100 CONTINUE
C---	 4000 IS:  READ NEXT COVERAGE RECORD FROM SCRATCH FILE
C---	 6050 IS:  CONTINUE WITH THE IBRKUP KLUGE PATCH.  
      IF(IBRKUP.EQ.0 .AND. (ILOOK.NE.0 .OR. NPOINT.NE.2)) GO TO 4000
      IF(IBRKUP.NE.0 .AND. (ILOOK.NE.0 .OR. NPOINT.NE.2)) GO TO 6050
C---	WAIT.  CHECK FOR RIGHT OR LEFT LOOKING SWATH.  
C---	CHECKING FOR THE ONE AND ONLY TIME.  ILOOK = 0 AND NPOINT = 2.
      CALL SANGL(ANGRAD,
     ?	POINT(8,1),
     ?	POINT(5,1),
     ?	POINT(5,2)  )
C---	IF RIGHT LOOKING SWATH, SET ILOOK = 1 AND READ NEXT RECORD.  
      IF(ANGRAD .GE. 0.0D0) ILOOK = 1
      IF(ANGRAD .GE. 0.0D0) GO TO 4000
C---	LEFT LOOKING SWATH.  SET ILOOK AND SHUFFLE THE PREVIOUS SWATH POINTS.
      ILOOK = 2
      if(print_flag .eq. 1) THEN
          print *,' '
          print *,' '
          print *,'sscvq.for:  SWATH INDICATES LEFT-LOOKING SENSOR'
          print *,' '
          print *,' '
      ENDIF
      BUF(1) = POINT(8,1)
      BUF(2) = POINT(9,1)
      BUF(3) = POINT(10,1)
      POINT(8,1) = POINT(5,1)
      POINT(9,1) = POINT(6,1)
      POINT(10,1) = POINT(7,1)
      POINT(5,1) = BUF(1)
      POINT(6,1) = BUF(2)
      POINT(7,1) = BUF(3)
      BUF(1) = POINT(8,2)
      BUF(2) = POINT(9,2)
      BUF(3) = POINT(10,2)
      POINT(8,2) = POINT(5,2)
      POINT(9,2) = POINT(6,2)
      POINT(10,2) = POINT(7,2)
      POINT(5,2) = BUF(1)
      POINT(6,2) = BUF(2)
      POINT(7,2) = BUF(3)
C---	PREVIOUS DAMAGE HAS BEEN FIXED; WE CAN NOW MOVE FORWARD.  
C---	NOW READ NEXT RECORD FROM SCRATCH FILE.  
C---	 4000 IS:  READ NEXT COVERAGE RECORD FROM SCRATCH FILE
C---	 6050 IS:  CONTINUE WITH THE IBRKUP KLUGE PATCH.  
      IF(IBRKUP .EQ. 0) GO TO 4000
      IF(IBRKUP .NE. 0) GO TO 6050
 8888 CONTINUE
      ISTAT = 1
      GO TO 9999
 9000 CONTINUE
C---	NORMAL END.  
      CLOSE (97)
      ISTAT = 0
 9999 CONTINUE
      if(print_flag .eq. 1) print *,'sscvq.for:  NRECS = ', NRECS,
     ?          '  ISTAT = ', ISTAT
      if(print_flag .eq. 1 .AND. ILOOK .EQ. 2) 
     ?    print *,'sscvq.for:  SWATH INDICATED LEFT-LOOKING SENSOR'
      RETURN
      END
