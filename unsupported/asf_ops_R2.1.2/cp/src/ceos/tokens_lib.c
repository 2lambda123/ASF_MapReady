/* mbatokens.c -- routines to read a text file 
		  and break it into tokens */

#include <stdio.h>
#include <unistd.h>
#include "defs.h"


static char sccsid_tokens_lib_c[] =
        "@(#)tokens_lib.c	1.6 96/10/01 13:51:47";

/* Added by Dan F. */
int next_token() ;


FILE *ODL_r_fp;
FILE *ODL_w_fp;

int toupper_sw = 0;		/* 1 = convert lower case to upper */
                                /* 0 = no conversion */
char token_separator;		/* holds last seen token separator */
static char ts[MAX_LINE] = "=";	/* token separator table */
static int col = 0;		/* current token place in line */
				/* 1 = first token on line */
				/* 2 = token in middle of line */
				/* 3 = token at end of line */
				/* 0 = beginning or end of file */


/* set_separators (s) --------------------------------------------------
	This routine sets up a user-defined set of token separators for
	use by the next_token routine.
*/

void set_separators(s)
	char *s;
{
        char *strcpy();
	strcpy(ts,s);
}


/* open_ODL_file(name,ext) -------------------------------------------------
	This routine tries to open a file for input.  If the open is
	successful, the routine returns 1, otherwise the routine 
	returns 0.  The filename is generated by concatenating name 
	and ext.
*/

int open_ODL_file(name,ext)
	char *name,*ext;
{
	char filnam[80];
	char *strcat(),*strcpy();

	strcat(strcpy(filnam,name),ext);
    /*
	printf("opening file %s\n",filnam);
    */
	if ((ODL_r_fp = fopen(filnam,"r")) == NULL) {
	    printf("\nError opening ODL file for reading");
	    return(0);
	}
	col = 0;
	return(1);
}

/* create_ODL_file(name,ext) -------------------------------------------------
	This routine tries to open a file for input.  If the open is
	successful, the routine returns 1, otherwise the routine 
	returns 0.  The filename is generated by concatenating name 
	and ext.
*/

int create_ODL_file(name,ext)
	char *name,*ext;
{
	char filnam[80];
	char *strcat(),*strcpy();

	strcat(strcpy(filnam,name),ext);
    /*
	printf("opening file %s\n",filnam);
    */
	if ((ODL_w_fp = fopen(filnam,"w")) == NULL) {
	    printf("\nError creating ODL file for writing");
	    return(0);
	}
	col = 0;
	return(1);
}



/* close_file() --------------------------------------------------------
	This routine closes a file previously opened by open_file.
*/

void close_file()
{
	if (ODL_r_fp != NULL)
	    fclose(ODL_r_fp);
}


/* move_ODL_r_fp(from,to)-----------------------------------------------------
	This routine moves the file pointer relative to the
	location specified by from.  It is moved 'to' number of
	bytes.  'from' is a character string and may be:
	"start", "current" or "end".  'to' may be a negative or
	positive integer.  The routine returns the number of
	bytes moved.
*/

int move_ODL_r_fp(from,to)
char    *from;    /* Can be "start", "current" or "end" */
int     to;       /* Number of bytes to move, negative or positive */
{
    int    bytes;   /* Number of bytes pointer is moved */
    int    c;      /* temp store for first char in 'from' */

    c = *from;

    switch(c) {
	case 's':      /* Move file pointer to start of file */
	    if (to < 0)  /* Negative move from start impossible */
		return(0);
	    fseek(ODL_r_fp,to,SEEK_SET);  /* Move pointer */
            bytes = ftell(ODL_r_fp);          /* Bytes moved */
	    break;
        case 'c':      /* Move file point relative to current pos */
	    bytes = ftell(ODL_r_fp);        /* Current position */
	    fseek(ODL_r_fp,to,SEEK_CUR);    /* Move pointer */
	    bytes = ftell(ODL_r_fp) - bytes;  /* Bytes moved */
	    break;
        case 'e':      /* Move file pointer relative to end */

            if (to > 0)  /* Positive move from end impossible */
		return(0);
            fseek(ODL_r_fp,0,SEEK_END);  /* move pointer to end*/
            bytes = ftell(ODL_r_fp);     /* End position */
	    fseek(ODL_r_fp,-to,SEEK_END);  /* Move pointer to new pos */
	    bytes = bytes - ftell(ODL_r_fp);  /* Bytes moved */
	    break;
        default:  return(0);  /* Illegal commmand */
    }
    return(bytes);  /* Return bytes move */
}


            
/* scan_for(t) ---------------------------------------------------------
	This routine scans the input file for a token which is at the
	front of a line of input, and matches the incoming token t.  If
	a match is found, the routine returns 1, otherwise 0.  If 0 is
	returned, the input file is at EOF.
*/

int scan_for(t)
	char *t;		/* string to match to */
{
	char s[MAX_LINE];		/* hold area for returned token */

	while (next_token(s)) {
	    if (strcmp(s,t) == 0)
		return(1);
	}
	return(0);
}


/* find_token(t)--------------------------------------------------------
	This routine scans the input file for a token that matches
	the incoming token t.  The token may be positioned anywhere
	in the file.  If a match is found, the routine returns 1,
	otherwise 0.  If 0 is returned, the input file is at EOF.
*/

int find_token(t)
	char *t;                 /* string to match to */
{
	char s[MAX_LINE];
	int  position;

	position = ftell(ODL_r_fp);   /* Get current file pointer pos */
	while (next_token(s) != 0) {  /* Not EOF */
	    if (strcmp(s,t) == 0)
		return(1);
        }
	if (position != 0)      /* Didn't start a beginning */
	{
	    fseek(ODL_r_fp,0,SEEK_SET);   /* Move ODL_r_fp to beginning */
	    while (next_token(s) != 0) {  /* Search again */
		if (strcmp(s,t) == 0)
		    return(1);
            }
        }
	return(0);
}



/* next_head(t) --------------------------------------------------------
	This routine reads the next token which is at the front of a 
	line, and returns the token in t.  The routine also returns 1
	if a token is returned, or 0 if at end of file.
*/

int next_head(t)
	char *t;	/* string to contain the returned token */
{
	int n = 1;

	while ((n = next_token(t)) > 1)
	    ;
	return(n);
}


/* get_int(i) ----------------------------------------------------------
	This routine reads the next token from the input stream, and
	converts it to an integer value in i.  The value returned by
	next_token is returned as the value of this routine as well.
	The token should be an ascii-coded decimal value, or an ascii-
	coded hex value preceded by "0x", or an ascii-coded binary
	value preceded by "0b".
*/

int get_int(i)
	int *i;		/* return variable for integer value */
{
	int n;		/* holds return value of next_token */
	char t[MAX_LINE];	/* holds token before conversion */
	char c;
	int neg;

	neg = ((c = getc(ODL_r_fp)) == '-');
	ungetc(c,ODL_r_fp);
	n = next_token(t);
	if (t[0] == '0' && toupper(t[1]) == 'X')
	    sscanf(&t[2],"%x",i);
	else if (t[0] == '0' && toupper(t[1]) == 'B')
	    *i = abtoi(&t[2]);
	else
	    *i = atoi(t);
	if (neg)
	    *i = -(*i);
	return(n);
}


/* abtoi(t) ------------------------------------------------------------
	This routine converts the ascii string in t into an integer
	value, and returns that value.  The conversion stops at the
	first character which is not a 0 or 1.
*/

int abtoi(t)
	char *t;
{
	int i = 0;

	while (*t == '0' || *t == '1')
	    i = (i << 1) + (*t++ == '1');
	return (i);
}


/* get_hex(i) ----------------------------------------------------------
	This routine reads the next token from the input stream, and
	converts it to an integer value in i.  The value returned by
	next_token is returned as the value of this routine as well.
	The token should be an ascii-coded hex value.
*/

int get_hex(i)
	int *i;		/* return variable for integer value */
{
	int n;		/* holds return value of next_token */
	char t[MAX_LINE];	/* holds token before conversion */
	char c;
	int neg;

	neg = ((c = getc(ODL_r_fp)) == '-');
	ungetc(c,ODL_r_fp);
	n = next_token(t);
	if (t[0] == '0' && toupper(t[1]) == 'X')
	    sscanf(&t[2],"%x",i);
	else
	    sscanf(t,"%x",i);
	if (neg)
	    *i = -(*i);
	return(n);
}


/* get_binary(i) -------------------------------------------------------
	This routine reads the next token from the input stream, and
	converts it to an integer value in i.  The value returned by
	next_token is returned as the value of this routine as well.
	The token should be an ascii-coded binary value.
*/

int get_binary(i)
	int *i;		/* return variable for integer value */
{
	int n;		/* holds return value of next_token */
	char t[MAX_LINE];	/* holds token before conversion */
	char c;
	int neg;
	int j;

	neg = ((c = getc(ODL_r_fp)) == '-');
	ungetc(c,ODL_r_fp);
	n = next_token(t);
	j = (t[0] == '0' && toupper(t[1]) == 'B') ? 2 : 0;
	*i = abtoi(&t[j]);
	if (neg)
	    *i = -(*i);
	return(n);
}


/* get_float(f) --------------------------------------------------------
	This routine reads the next token from the input stream, and
	converts it to a floating point value in f.  The value returned 
	by next_token is returned as the value of this routine as well.
	The token should be an ascii-coded floating point value.
*/

int get_float(f)
	float *f;	/* return variable for floating point value */
{
	int n;		/* holds return value of next_token */
	char t[MAX_LINE];	/* holds token before conversion */
	double atof();

	n = next_token(t);
	*f = atof(t);
	return(n);
}


/* get_double(d) -------------------------------------------------------
	This routine reads the next token from the input stream, and
	converts it to a double floating point value in f.  The value 
	returned by next_token is returned as the value of this routine 
	as well.  The token should be an ascii-coded floating point 
	value.
*/

int get_double(d)
	double *d;	/* return variable for floating point value */
{
	int n;		/* holds return value of next_token */
	char t[MAX_LINE];	/* holds token before conversion */
	double atof();

	n = next_token(t);
	*d = atof(t);
	return(n);
}



/* get_long(l) ----------------------------------------------------------
	This routine reads the next token from the input stream, and
	converts it to an long value in l.  The value returned by
	next_token is returned as the value of this routine as well.
	The token should be an ascii-coded decimal value.
	Added by Dan F. 
*/

int get_long(l)
	long *l;		/* return variable for long value */
{
	int n;		        /* holds return value of next_token */
	char t[MAX_LINE];	/* holds token before conversion */
	long atol();

	n = next_token(t);
	*l = atol(t);
	return(n);
}

int get_array ( char *t,  int nelems, int type)
{
        char  *c_array =  t;
        int   *i_array = (int *) t;
        float *f_array = (float *) t;
	double *d_array = (double *) t;
	long  *l_array = (long *) t;  /* Added by Dan F. */
	
	int i;
	char token[MAX_LINE];
        char *strcpy();
	
	/* type 0=char , 1=integer, 2=float 3=double 4=long */
	
	scan_for("(");
        set_separators(", ");
	
	for (i=0; i<nelems; i++) {
	    switch (type) {
		case 0:
		   next_token( token);
		   strcpy( c_array+i,  token );
		   break;
		case 1:
		   get_int( i_array+i );
		   break;
		case 2:
		   get_float( f_array+i );
		   break;
		case 3:
		   get_double( d_array+i );
		   break;
		case 4:
		   get_long( l_array+i );
		   break;
	    }
	}
	
        scan_for(")");
	set_separators("= ");
	return(1);
}


/* flush_line () -------------------------------------------------------
	This routine scans through the input file until the end of the
	current line is reached.
*/

void flush_line ()
{
	char t[MAX_LINE];

	while (token_separator != '\n')
	    next_token (t);
}


/* next_token(t) -------------------------------------------------------
	This routine reads the next token from the input file pointed to
	by ODL_r_fp, and returns the token in t.  The routine also returns:
		0 = file is at EOF
		1 = token is first token on line
		2 = token is in middle of line
		3 = token is last token on line
		    Note: if the last token before a newline is followed
		    by a separator, the next line is treated as a 
		    continuation line.
*/

int next_token(t)
	char *t;
{
	int c;			/* character just read in */
	int token_start = 0;	/* token position indicator */
	char q, *s;

	while ((c = getc(ODL_r_fp)) != EOF) {
	    for (s = ts; *s; s++)
		if (c == *s) {
		    token_separator = c;
		    if (token_start) {
			*t = '\0';
			if (++col > 2)
			    col = 2;
			return(col);
		    }
		    c = ' ';
		    break;
		}
	    switch(c) {
		case ' ':	/* white space characters */
		case '\t':
		    break;
		case '\n':	/* new line token separator */
		    if (token_start) {
			col = 0;
			*t = '\0';
			token_separator = c;
			return(3);
		    }
		    break;
		default:	/* normal characters */
		    *t++ = (toupper_sw) ? toupper(c) : c ;
		    token_start = 1;
		    if ((c == '\'') || (c == '\"')) {	/* quote strings */
			q = c;
			while ((c = getc(ODL_r_fp)) != q) {
			    *t++ = c;
			}
			*t++ = c;
		    }
		    break;
	    }  /* switch */
	}  /* while */

	if (token_start) {	/* end of file */
	    *t = '\0';
	    return(3);
	}
	else
	    return(0);
}
