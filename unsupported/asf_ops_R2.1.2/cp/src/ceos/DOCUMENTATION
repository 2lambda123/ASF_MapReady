/* To test the program called ceos (see Makefile), change the Makefile for the
   makedefs.XXX if needed (SGI is default).

   Type,  "ceos",  the usage line appears.

   Usage: ceos ldr=leader_file or vdf=vdf_name or tape=tape_name [out=leader_file] [debug]

   The options "vdf" and "tape" are not currently available
   options in [ ] are optional

   "ldr" specifies the CEOS leader or trailer file to be read/placed into
   the internal tree structure.

   "out" specifies the CEOS formatted file to which the internal tree
   structures are written.

   "debug" formats to the screen the contents of "ldr" records.

   The internal tree structures are defined in oceos.h

*/


/* 
   The following is a template for user's who want to write a simple
   routine that processes ODL files into CEOS format.  The are library
   functions that allocate, access, write, and free the structures
   defined in the oceos.h header file. 
*/

/* 
   The code has not been put into a single libary. A compile link line
   would be 

   cc -o my_main my_main.c process_ldr.c io_utils.c

*/

#include <stdio.h>
#include <strings.h>
#include <stdlib.h>
#include <ctype.h>
#include "defs.h"
#include "extern.h"


int Debug=0;
main (argc, argv)
	int argc;
	char **argv;
{
    char outputfile_name[80];

    write_to_ceos_file(outfile_name);
}


void write_to_ceos_file(char *outputfile_name)

   SARL_ptr* tree;
   Sarl_Desc_Rec* fdr;
   int ret;

   /* allocate memory for a SARL structure */

   if ( ( tree = Allocate_SARL() ) == NULL) {
      printf("\n Failed to Allocate_SARL");
      return(0);
   }


   /* 

     The user is required to fill in the File Descriptor structure (fdr).
     A pointer to this structure is returned by Get_L_FDR

   */

    fdr = Get_L_FDR(tree);

   /* 

      Based on the contents of the FDR structure you call Allocate_SARL_ODR
      to allocate memory for the remaining record types
    */

   
    Allocate_SARL_ODR(tree);

   /* 

      Use any of the Get_L_XXX() routines to return a pointer to that
      record type (XXX) of the given tree and then the user
      fills in the structure members.

   */




    /* 

       When the user has finished filling in the desired records,
       he calls  Write_ODL_SARL then Free_SARL which returns the
       memory back the system

    */

    Write_ODL_SARL( outputfile_name, tree);
    Free_SARL( tree );
}

     

Library routine documentation  
----------------------------- 

*Note: Words in capitals are defined in file "defs.h".

       Phrases of the form {member " "} refer to structure members as
       shown in the "oceos.h"  header file.

Record types processed herein:
      File Descriptor
      Dataset Summary
      Map Projection
      Platform Position
      Attitude Data
      Radiometric Data
      Radiometric Compensation
      Data Quality Summary
      Data Histogram
      Range Spectra
      Digital Elevation
      Facility Related Data


FILE* Open_LDR(char* name, int mode);
      Purpose:   Opens a leader file.
      Inputs:    name - name of file to open
                 mode - access either READ_ONLY, WRITE_ONLY
      Called by: Write_ODL_SARL
      Returns:   File pointer
                  
       
SARL_ptr* Allocate_SARL( void );
      Purpose:   Allocates memory for the leader tree structure. 
                 Additionlly, allocates a work area for reading/
                 writing the CEOS data records. Current work 
                 area size is set to 20000 bytes.
               
                 The tree structure consists initally of
                 space for the File Descriptor Record data
                 and a NULL pointer to each record type 
                 structure.
      Returns:   A pointer to the leader tree structure or NULL

int Allocate_SARL_ODR( SARL_ptr* tree );
      Purpose:   Calls the memory allocation routine for each of the 
                 record types. The File Descriptor structure must
                 have been filled otherwise the number of records
                 for each type is zero and allocation is not performed.
      Inputs:    tree - A valid pointer to a leader structure.            
      Returns:   Returns one of,
                    TRUE, sucessful
                    FALSE, error
      Calls:     Allocate_Data_Sum
                 Allocate_Map_Proj
                 Allocate_Plat_Pos
                 Allocate_Att_Data
                 Allocate_Radi_Data
                 Allocate_Radi_Comp
                 Allocate_Qual_Sum
                 Allocate_Data_Hist
                 Allocate_Rng_Spec
                 Allocate_Digital_Elev
                 Allocate_Fac_Related


Dataset_Sum*   Allocate_Data_Sum( tree );
Map_Proj*      Allocate_Map_Proj( tree );
Pos_Data*      Allocate_Plat_Pos( tree );
Att_Data*      Allocate_Att_Data( tree );
Radi_Data*     Allocate_Radi_Data( tree );
Radi_Comp*     Allocate_Radi_Comp( tree );
Qual_Sum*      Allocate_Qual_Sum( tree );
Data_Hist*     Allocate_Data_Hist( tree );
Rng_Spec*      Allocate_Rng_Spec( tree );
Digital_Elev*  Allocate_Digital_Elev( tree );
Fac_Related*   Allocate_Fac_Related( tree );
      Purpose:   Each routine allocates memory for that record type
                 based on the contents of the File Descriptor structure,
                 references appropriate {member "descript->n_?"}.
      Inputs:    tree - A valid pointer to a leader structure. 
      Returns:   Each routine returns a pointer to the list of records or NULL. 


Dem_Desc*  Allocate_DEM_sets( Digital_Elev* e );
      Purpose:   Allocates memory for the DEM data descriptor data sets.
                 References {member "num_polys"} the number of polygons 
                 described in this record.
      Inputs:    e - A valid pointer to a Digital Elevation Model structure.
      Returns:   A pointer to the list of DEM data descriptor data sets or NULL
                 Return pointer same as {member "set"}


Corner_Pts* Allocate_DEM_pts( Dem_Desc* set );
      Purpose:   Allocates memory for the number of corner points for current
                 polygon in the current DEM data descriptor data set.
                 References {member "num_crnr_pts"}.
      Inputs:    set - A valid pointer to a DEM data descriptor data set
                 structure.
      Returns:   A pointer to the list of Corner points (lat, and long.) or NULL
                 Return pointer same as {member "pts"}


Hist_Data_Set* Allocate_Hist_Data_Set( Data_Hist* h );
      Purpose:   Allocates memory for the number of histogram table sets 
                 in this record structure. References {member "ntab"}
      Inputs:    h - A valid pointer to a Data Histogram record structure
      Returns:   A pointer to the list of histogram data set tables or NULL.
                 Return pointer same as {member "data_set"}


Att_Vect_Rec* Allocate_Attitude_Sets( Att_Data* a);
      Purpose:   Allocates memory for the number of attitude data sets in
                 a AttitudeData record structure. References {member "npoint"}.
      Inputs:    a - A valid pointer to a Attitude Data record structure
      Returns:   A pointer to the list of attitude data sets pr NULL.
                 Return pointer same as {member "att_vect"}

int Read_FDR_SARL( FILE* fp, SARL_ptr* tree );
      Purpose:   Reads the CEOS leader file scanning for the 
                 File Descriptor Record only. If found, the
                 descriptor record info is placesd in the 
                 leader tree structure.
      Inputs:    fp - Valid file pointer
                 tree - Valid leader tree structure
      Returns:   Returns one of,
                    MATCH_FOUND
                    READ_ERROR
                    END_OF_FILE
      Calls:     read_record
                 Decode_SARL_FDR


void Decode_SARL_FDR( unsigned char* buf, Sarl_Desc_Rec* f );
      Purpose:   Processes the current contents of the work area
                 and fills the file descriptor structure of the 
                 leader tree.
      Inputs:    buf - Buffer/work area containing a record
                 f - A valid pointer to a file descriptor 
                     structure
      Called by: Read_FDR_SARL
      Returns:   Returns one of,
                    DECODE_ERROR
                    DECODE_OK


void Free_SARL( SARL_ptr* tree);
      Purpose:   Frees all memory associated with tree
                 and the work area.
      Inputs:    main tree structure


int Read_ALL_SARL( FILE* fp, SARL_ptr* tree );
      Purpose:   Reads the CEOS leader file scanning for all
                 record types except the File Descriptor Record
      Inputs:    fp - Valid file pointer
                 tree - Valid leader tree structure
      Returns:   Returns one of,
                    READ_ERROR
                    END_OF_FILE
      Calls:     read_record
                 Decode_SARL_DSR
                 Decode_SARL_MPR
                 Decode_SARL_PPR
                 Decode_SARL_ATR
                 Decode_SARL_RDR
                 Decode_SARL_RCR
                 Decode_SARL_DQSR
                 Decode_SARL_DHR
                 Decode_SARL_RSR
                 Decode_SARL_DER
                 Decode_SARL_FRR

void Decode_SARL_FDR( unsigned char* buf, Sarl_Desc_Rec* f );
      Purpose:   Processes the current contents of the work area
                 and fills the file descriptor structure of the 
                 leader tree.
      Inputs:    buf - Buffer/work area containing a record
                 f - A valid pointer to a file descriptor 
                     structure
      Called by: Read_FDR_SARL
      Returns:   Returns one of,
                    DECODE_ERROR
                    DECODE_OK


int  Decode_SARL_DSR( unsigned char* buf, SARL_ptr* tree );
int  Decode_SARL_MPR( unsigned char* buf, SARL_ptr* tree );
int  Decode_SARL_PPR( unsigned char* buf, SARL_ptr* tree );
int  Decode_SARL_ATR( unsigned char* buf, SARL_ptr* tree );
int  Decode_SARL_RDR( unsigned char* buf, SARL_ptr* tree );
int  Decode_SARL_RCR( unsigned char* buf, SARL_ptr* tree );
int  Decode_SARL_DQSR( unsigned char* buf, SARL_ptr* tree );
int  Decode_SARL_DHR( unsigned char* buf, SARL_ptr* tree );
int  Decode_SARL_RSR( unsigned char* buf, SARL_ptr* tree );
int  Decode_SARL_DER( unsigned char* buf, SARL_ptr* tree );
int  Decode_SARL_FRR( unsigned char* buf, SARL_ptr* tree );
      Purpose:   Each of these routines processes the current
                 contents of the work area and fills the tree
                 for that record type. If multiple records of
                 any type are contained in the CEOS leader file
                 they are placed at the end of the list of that
                 record type
      Inputs:    buf - Buffer/work area containing a record
                 t - A valid pointer to a tree structure
      Called by: Read_ALL_SARL
      Returns:   Returns one of,
                    DECODE_ERROR
                    DECODE_OK


int Write_ODL_SARL( char name[], SARL_ptr* tree );
      Purpose:   Opens the CEOS leader file for writing the
                 contents of the leader tree structure
      Inputs:    name - name of file to open
                 tree - A valid pointer to a leader tree
                        structure.
      Calls:     Open_LDR
                 Write_L_FDR_ODL
                 Write_L_DSS_ODL
                 Write_L_MP_ODL
                 Write_L_PP_ODL
                 Write_L_AT_ODL
                 Write_L_RD_ODL
                 Write_L_RC_ODL
                 Write_L_DQS_ODL
                 Write_L_RS_ODL
                 Write_L_DH_ODL
                 Write_L_DE_ODL
                 Write_L_FR_ODL              
      Returns:   Returns one of,
                    TRUE, sucessful
                    FALSE, error


int Write_L_FDR_ODL( Sarl_Desc_Rec* f, FILE* out );
int Write_L_DSS_ODL( Dataset_Sum* f, FILE* out, int mode );
int Write_L_MP_ODL( Map_Proj* f, FILE* out, int mode );
int Write_L_PP_ODL( Pos_Data* f, FILE* out, int mode );
int Write_L_AT_ODL( Att_Data* f, FILE* out, int mode );
int Write_L_RD_ODL( Radi_Data* f, FILE* out, int mode );
int Write_L_RC_ODL( Radi_Comp* f, FILE* out, int mode );
int Write_L_DQS_ODL( Qual_Sum* f, FILE* out, int mode );
int Write_L_RS_ODL( Rng_Spec* f, FILE* out, int mode );
int Write_L_DH_ODL( Data_Hist* f, FILE* out, int mode );
int Write_L_DE_ODL( Digital_Elev* f, FILE* out, int mode );
int Write_L_FR_ODL( Fac_Related* f, FILE* out, int mode );
      Purpose:   Each of these routines transfers the contents
                 of the tree structure to the work area and 
                 writes the records to the CEOS leader file.
      Inputs:    f - Data record type to be transferred
                 out - File pointer to the CEOS output file
                 mode - States if multiple records are written
                        0 - This record and any child records
                        1 - This record only
      Calls:     write_record
                 get_recalc_status
                 recalc_length
                 get_rec_length
                 reset_rec_length
      Returns:   Returns one of,
                    TRUE, sucessful
                    FALSE, error
      Notes:     Each of these routines will calculate a record
                 length if the descriptor record length member is
                 0 (zero).
                 If the Debug flag is set each of these routines
                 prints to the terminal screen the contents of that
                 record type. Each of these routines can be called 
                 with an  "out" file pointer of NULL, allowing you
                 to debug without creating a CEOS leader file.
                 
   
 
Sarl_Desc_Rec* Get_L_FDR( SARL_ptr* tree );
Dataset_Sum* Get_L_DSS( SARL_ptr* tree );
Map_Proj* Get_L_MP( SARL_ptr* tree );
Pos_Data* Get_L_PP( SARL_ptr* tree );
Att_Data* Get_L_AT( SARL_ptr* tree );
Radi_Data* Get_L_RD( SARL_ptr* tree );
Radi_Comp* Get_L_RC( SARL_ptr* tree );
Qual_Sum* Get_L_DQS( SARL_ptr* tree );
Data_Hist* Get_L_DH( SARL_ptr* tree );
Rng_Spec* Get_L_RS( SARL_ptr* tree );
Digital_Elev* Get_L_DE( SARL_ptr* tree );
Fac_Related* Get_L_FR( SARL_ptr* tree );
      Purpose:   Each of these routines returns a pointer to
                 the first record of that type in the leader
                 tree structure.
      Inputs:    tree -  A valid pointer to a leader tree structure
      Returns:   Returns one of,
                    Valid pointer 
                    NULL pointer

Dataset_Sum* Get_DSS_Num( SARL_ptr* t, int num );
Map_Proj* Get_MP_Num( SARL_ptr* t, int num );
Pos_Data* Get_PP_Num( SARL_ptr* t, int num );
Att_Data* Get_AT_Num( SARL_ptr* t, int num );
Radi_Data* Get_RD_Num( SARL_ptr* t, int num );
Radi_Comp* Get_RC_Num( SARL_ptr* t, int num );
Qual_Sum* Get_DQS_Num( SARL_ptr* t, int num );
Data_Hist* Get_DH_Num( SARL_ptr* t, int num );
Rng_Spec* Get_RS_Num( SARL_ptr* t, int num );
Digital_Elev* Get_DE_Num( SARL_ptr* t, int num );
Fac_Related* Get_FR_Num( SARL_ptr* t, int mode );
      Purpose:   Each of these routines returns a pointer to
                 the nth record of that type in the leader
                 tree structure.
      Inputs:    tree -  A valid pointer to a leader tree structure
                 num - the nth record. Starts from 1
                       num = 0 or num > number of records return NULL
      Returns:   Returns one of,
                    Valid pointer 
                    NULL pointer
