static char *sccs = "@(#)ims_URF2DAR.c	1.4  07/22/97";
/******************************************************************************
**
** File:        ims_URF2DAR.c
**
** Function:    This application will read in a User Request File (URF),
**              which has been generated by the Swath Planner (SPA), and
**              convert it to a DAR.
**
** Author:      Vance Heron
**
******************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <syslog.h>
#include <sys/utsname.h>
#include <errno.h>

#include <odldef.h>
#include <odlinter.h>
#include <ims_query.h>
#include <ims_order.h>
#include <ims_archive.h>
#include <ims_util.h>


#define LINELEN 100
#define MAX_BEAM 20
#ifndef FALSE
#define FALSE 0
#endif
#ifndef TRUE
#define TRUE 1
#endif

struct s_c0
{
   int day_cyc; 
   int rev_cyc;
   int c0yr;
   int c0dy;
   int c0hr;
   int c0min;
   float c0sec;
   float c0lon;
};

struct s_t1 {
   char nm1[100];   /* First Name */
   char nm2[100];   /* Last Name */
   char auth[100];  /* Authenticator */
   char src[100];   /* Source Name - (RADARSAT-1) */
   char bill[100];  /* Billing ID */
   char sens[100];  /* Sensor  (SAR) */
   char mode[100];  /* Radarsat Mode */
   char qflag[100]; /* Quicklook Flag */
   char pri[100];   /* Order Priority */
};

void gen_dar(
   char *outfile,
   struct s_t1 *prm,
   char *start,
   char *stop,
   int obnum,
   char *infile,
   float lat,
   float lon
);

void get_fields(
   char *input, 
   int *st_cyc, 
   float *st_rev, 
   float *dur, 
   int *nd_cyc, 
   char *beam
);

static void cyc2tmst(
   struct s_c0 *c0,
   int st_cyc, 
   float st_rev, 
   char *str_tm 
);

static int read_init_file(
   IMS_MSG_STRUCT *msgDesc,
   struct s_t1 *prm,
   struct s_c0 *c0
);

float cyc2lat(float rev);
float cyc2lon(
   float rev,
   struct s_c0 *c0
);
void beam2mode(char *beam, char *mode);

char dir[100];

main(int argc, char **argv)
{
/* IMS STUFF */
char *programName;
char banner[IMS_HOST_LEN+IMS_PROGRAM_LEN+3];
char hostName[IMS_HOST_LEN];
struct utsname uname_info;    /* Structure for uname() */
FILE    *datafile;  
AGGREGATE RxTree;
int   order_id, first_order, status;
int gen_only;
IMS_MSG_STRUCT *msgDesc;
/* END OF IMS STUFF */

FILE *ifp;
char linein[LINELEN+1], *ptr, ofnam[100], ifnam[100], ofdir[80];
int found, swath_no;
int st_cyc, nd_cyc; 
float st_rev, dur;
float ct_lat, ct_lon;
char beam[MAX_BEAM+1], mode[20];
char strt_tm[30], stop_tm[30];

struct s_t1 t1;
struct s_c0 c0;


/* IMS STUFF */
  /* setup program and host names */
	programName = ims_extractFileName (argv[0]);
  (void) uname (&uname_info);
  (void) strncpy (hostName, uname_info.nodename, IMS_HOST_LEN);
  hostName[IMS_HOST_LEN] = '\0';  /* Just in case. */
  
  /* allocate message structure */
  if ((msgDesc = (IMS_MSG_STRUCT *)ims_msgStructAlloc ()) == NULL)
  {
    fprintf (stderr, "IMS_MSG_STRUCT allocation error.");
    exit (-1);
  } 

  /* initialize message structure */
	(void) ims_msgSubSystem (msgDesc, "IMS");
  (void) ims_msgProgramName (msgDesc, programName);
  (void) sprintf (banner, "%s::%s", hostName, programName);
  (void) ims_msgBanner (msgDesc, banner, IMS_MSG_ALLBANNER);
  (void) ims_msgOpenSyslog (msgDesc, "IMS/DADS:", LOG_LOCAL5);
  (void) ims_msgSybErrHndlFlag (msgDesc, IMS_ON);
  (void) ims_msgSybMsgHndlFlag (msgDesc, IMS_ON);
/* END OF IMS STUFF */


  if (argc < 2)
  {
    printf ("usage: %s [-g] <fname>\n",argv[0]);
    ims_msgStructFree  (msgDesc);
    exit(0);
  } 

  if (read_init_file(msgDesc, &t1, &c0) == -1)
  {
    ims_msgStructFree  (msgDesc);
    exit(-1);
  }
  gen_only = FALSE;
  strncpy(ifnam, argv[1], 99);
  if (strcmp(ifnam, "-g") == 0)
  {
    if (argc < 3)
    {
      printf ("usage: %s [-g] <fname>\n",argv[0]);
      ims_msgStructFree  (msgDesc);
      exit(0);
    }
    gen_only = TRUE;
    strncpy(ifnam, argv[2], 99);
  }
  if ((ifp = fopen(ifnam,"r")) == NULL)
  {
     (void) ims_msg (msgDesc, IMS_ERROR,
        "Could not open URF file '%s'. %s",
        ifnam, strerror(errno));
     ims_msgStructFree  (msgDesc);
     exit(-1);
  }
   
   /* skip to first "swath" request line in file */
   found = FALSE;
   while (!found)
   {
      fgets(linein, LINELEN, ifp);
      ptr = strstr(linein,"NAME=\"swath");
      found = (ptr != NULL);
   }

   (void) ims_msg (msgDesc, IMS_INFO,
      "Processing swath requests found in '%s'.", ifnam);

   swath_no = 0;
   while (found)
   {
      get_fields(linein, &st_cyc, &st_rev, &dur, &nd_cyc, beam);
      beam2mode(beam,mode);
      if (strcmp(mode,"NONE") != 0) {
         strcpy(t1.mode,mode);
      } else {
         fprintf (stderr,"Illegal Mode found  - %s, skipping record\n",beam);
         goto NXT;
      }

#ifdef DBG
      printf ("DBG:st_cyc %d,  st_rev %f, dur %f nd_cyc %d beam %s -> %s \n",
         st_cyc, st_rev, dur, nd_cyc, beam, mode);
#endif

      /* conver decimal orbit to ODL time string */ 
      cyc2tmst(&c0, st_cyc, st_rev, strt_tm );
      cyc2tmst(&c0, st_cyc, st_rev+dur,  stop_tm);

      /* get approximate lat & lon  - will use big radius */
      ct_lat = cyc2lat(st_rev + (dur/2.0));
      ct_lon = cyc2lon(st_rev + (dur/2.0), &c0);

			if (swath_no == 0) printf ("\n");
      printf ("."); fflush(stdout);
      swath_no++;
      if ((swath_no % 20) == 0)
      {
         printf (" %d\n",swath_no);
         fflush (stdout);
      }
      sprintf (ofnam, "%s/dar%d.odl", dir, swath_no);
      gen_dar(ofnam, &t1, strt_tm, stop_tm, swath_no, ifnam, ct_lat, ct_lon);

/* IMS STUFF */
       if (!gen_only)
       {
          if ((datafile = fopen (ofnam, "r")) == NULL)
          {
               ims_msg ( msgDesc, IMS_FATAL,
                   "Fail to open ODL label file");
               ims_msgStructFree  (msgDesc);
               exit (-1);
          }

          if ( (RxTree = NewAggregate(NULL, KA_GROUP, "root", NULL)) == NULL)
          {
               ims_msg (msgDesc, IMS_FATAL,
                  "Fail to initialize an ODL tree");
               fclose (datafile);
               ims_msgStructFree  (msgDesc);
               exit (-1);
          }

          if ( (ReadLabel (datafile, RxTree)) == NULL)
          {
               ims_msg (msgDesc, IMS_FATAL,
                   "Fail to read ODL label file");
               fclose (datafile);
               RemoveAggregate (RxTree);
               RxTree = NULL;
               ims_msgStructFree  (msgDesc);
               exit (-1);
          }

          fclose(datafile);
          (void) ims_msgStderrFlag (msgDesc, IMS_OFF);

          if ( (status = ims_order (msgDesc, RxTree, &order_id)) < IMS_OK)
          {
               (void) ims_msgStderrFlag (msgDesc, IMS_ON);
               ims_msg (msgDesc, IMS_FATAL,
                     "Fail to place order to IMS");
               RemoveAggregate (RxTree);
               RxTree = NULL;
               ims_msgStructFree  (msgDesc);
               exit (-1);
          }
          (void) ims_msgStderrFlag (msgDesc, IMS_ON);
          RemoveAggregate (RxTree);
          if (swath_no == 1) first_order = order_id;
      }
      RxTree = NULL;
/* END OF IMS STUFF */

NXT:
      found = FALSE;
      while (!found && !feof(ifp))
      {
         fgets(linein, LINELEN, ifp);
         ptr = strstr(linein,"NAME=\"swath");
         found = (ptr != NULL);
      }
   }
   if ((swath_no % 20) != 0)
   {
      printf (" %d\n",swath_no);
      fflush (stdout);
   }

   if (!gen_only)
   {
      (void) ims_msg (msgDesc, IMS_INFO,
         "Submitted '%d' DAR's, Order ID's '%d' to '%d'.",
         swath_no, first_order, order_id);
   } else {
      (void) ims_msg (msgDesc, IMS_INFO,
         "Generated '%d' DAR's, Submit using 'ims_orderClnt'.",
         swath_no);
   }

   fclose(ifp);
   ims_msgStructFree  (msgDesc);
   exit(0);
}

void get_fields(
   char *input, 
   int *st_cyc, 
   float *st_rev, 
   float *dur, 
   int *nd_cyc, 
   char *beam
)
{
char *ptr;

   ptr = strstr(input, "VALUE");
   ptr = strchr(ptr,'"'); ptr++;
   *st_cyc = atoi(ptr);
   ptr = strchr(ptr,'|'); ptr++;
   *st_rev = atof(ptr);
   ptr = strchr(ptr,'|'); ptr++;
   *dur = atof(ptr);
   ptr = strchr(ptr,'|'); ptr++;
   *nd_cyc = atoi(ptr);
   ptr = strchr(ptr,'|'); ptr++;
   strncpy(beam, ptr, MAX_BEAM);
   ptr = strchr(beam,'|');
   if (ptr != NULL) *ptr = '\0';
}


static int read_init_file(
   IMS_MSG_STRUCT *msgDesc,
   struct s_t1 *prm,
   struct s_c0 *c0
)
{

FILE *fp;
char linein[80], key[80], val[80];
char configfn[100], *tmpptr;

   tmpptr = getenv("IMS_URF2DAR_CONFIG");

   if (tmpptr == NULL)
   {
      (void) ims_msg (msgDesc, IMS_ERROR,
         "The environment variable 'IMS_URF2DAR_CONFIG' is not set.");
      return(-1);
   }

   strcpy(configfn,tmpptr);

   if ((fp = fopen(configfn, "r")) == NULL)
   {
      (void) ims_msg (msgDesc, IMS_ERROR,
         "Could not open config file '%s'. %s",
         configfn, strerror(errno));
      return(-1);
   }

   while (fgets(linein,80,fp) !=NULL)
   {
      tmpptr = strchr(linein,'#');         /* remove comment */
      if (tmpptr != NULL) *tmpptr = '\0';

      tmpptr = strchr(linein,'\n');        /* remove trailing newline */
      if (tmpptr != NULL) *tmpptr = '\0';

      tmpptr = strchr(linein,'=');         /* need <key>=<value> */
      if (tmpptr == NULL) continue;
      *tmpptr = (char)' ';

      sscanf(linein,"%s %s",key,val);

      if (strcmp(key,"T1_PATH") == 0) strcpy(dir,val);
      if (strcmp(key, "T1_D_C") == 0) c0->day_cyc = atoi(val);
      if (strcmp(key, "T1_R_C") == 0) c0->rev_cyc = atoi(val);
      if (strcmp(key, "T1_C0YR") == 0) c0->c0yr = atoi(val);
      if (strcmp(key, "T1_C0DY") == 0) c0->c0dy = atoi(val);
      if (strcmp(key, "T1_C0HR") == 0) c0->c0hr = atoi(val);
      if (strcmp(key, "T1_C0MIN") == 0) c0->c0min = atoi(val);
      if (strcmp(key, "T1_C0SEC") == 0) c0->c0sec = atof(val);
      if (strcmp(key, "T1_C0LON") == 0) c0->c0lon = atof(val);

      if (strcmp(key, "T1_NM1") == 0) strcpy(prm->nm1,val);
      if (strcmp(key, "T1_NM2") == 0)  strcpy(prm->nm2,val);
      if (strcmp(key, "T1_AUTH") == 0)  strcpy(prm->auth,val);
      if (strcmp(key, "T1_SRC") == 0)  strcpy(prm->src,val);
      if (strcmp(key, "T1_BILL") == 0) strcpy(prm->bill,val);
      if (strcmp(key, "T1_SENS") == 0) strcpy(prm->sens,val);
      if (strcmp(key, "T1_QFLAG") == 0) strcpy(prm->qflag,val);
      if (strcmp(key, "T1_PRI") == 0) strcpy(prm->pri,val);

   }
   return(0);
}


int diy(int yr)
{
   return ((yr % 4) == 0 && (yr % 100) ? 366 : 365);
}

void cyc2tmst(
   struct s_c0 *c0,
   int st_cyc, 
   float st_rev, 
   char *str_tm
)
{

/* START_DATE  = 1996-03-01T03:04:09.004Z - sample date */

#define SEC_DAY 24*60*60
int dim[2][12] =
{{ 31, 28, 31, 30, 31, 31, 30, 31, 30, 31, 30, 31 },
 { 31, 29, 31, 30, 31, 31, 30, 31, 30, 31, 30, 31 }};

int sec_cyc, tmp;
int d_day, d_hr, d_min;
int strt_yr, strt_dy, strt_hr, strt_min;
float d_sec, d_start, sec_rev, strt_sec;

   /* convert time in cycle/orbit to string */

   /* derived constants */
   sec_cyc = c0->day_cyc * SEC_DAY;
   sec_rev = (float) sec_cyc / (float) c0->rev_cyc;

   /* seconds to start of swath */
   d_start = (float)(st_cyc * sec_cyc) + 
             ((float)st_rev * sec_rev);

   d_start += sec_rev;    /* spa uses Rev1 time vs Rev0 */

   tmp = (int) d_start;   /* integer delta seconds */

   for (d_day = 0; tmp >= SEC_DAY;  d_day++) tmp -= SEC_DAY;
   for (d_hr = 0; tmp >= 3600;  d_hr++) tmp -= 3600;
   for (d_min = 0; tmp >= 60;  d_min++) tmp -= 60;

   d_sec = d_start; 
   d_sec -= d_day * SEC_DAY;
   d_sec -= d_hr * 3600;
   d_sec -= d_min* 60;

   strt_yr =  c0->c0yr; 
   strt_dy =  c0->c0dy  + d_day;
   strt_hr =  c0->c0hr  + d_hr;
   strt_min = c0->c0min + d_min;
   strt_sec = c0->c0sec + d_sec;

   while (strt_sec >= 60.0) { strt_sec -= 60.0; strt_min += 1;}
   while (strt_min >= 60) { strt_min -= 60; strt_hr += 1;}
   while ((strt_hr >= 24) || ((strt_hr == 24) && (strt_min > 0)))
   { 
      strt_hr -= 24; 
      strt_dy += 1;
   }

   while (strt_dy > diy(strt_yr)) { 
      strt_dy -= diy(strt_yr);
      strt_yr += 1;
   }
   sprintf (str_tm,"%d-%03dT%02d:%02d:%06.3fZ",
            strt_yr, strt_dy, strt_hr, strt_min, strt_sec);

}

void gen_dar(
   char *outfile,
   struct s_t1 *prm,
   char *start,
   char *stop,
   int obnum,
   char *infile,
   float lat,
   float lon
)
{
FILE *ofp;

   if ((ofp=fopen(outfile,"w+")) == NULL)
   {
      printf ("Error opening output file %s\n",outfile);
      exit(0);
   }

   fprintf (ofp, "GROUP = DAR_REQUEST\n");
   fprintf (ofp, "   FIRST_NAME  = \"%s\"\n",prm->nm1);
   fprintf (ofp, "   LAST_NAME   = \"%s\"\n",prm->nm2);
   fprintf (ofp, "   AUTHENTICATOR = \"%s\"\n",prm->auth);
   fprintf (ofp, "   SOURCE_NAME = \"%s\"\n",prm->src);
   fprintf (ofp, "   BILLING_ID  = \"%s\"\n",prm->bill);
   fprintf (ofp, "   SENSOR_NAME = \"%s\"\n",prm->sens);
   fprintf (ofp, "   MODE        = \"%s\"\n",prm->mode);
   if (strcmp (prm->qflag, "") == 0)
   {
      fprintf (ofp, "   QUICK_LOOK   = \"Y\"\n");
   }
   else
   {
      fprintf (ofp, "   QUICK_LOOK   = \"%s\"\n",prm->qflag);
   }
   fprintf (ofp, "   START_DATE  = %s\n",start);
   fprintf (ofp, "   STOP_DATE   = %s\n",stop);
   fprintf (ofp, "   OB_NUMBER   = %d\n",obnum);
   fprintf (ofp, "   OB_FREQUENCY = \"1\"\n");
   fprintf (ofp, "   DIRECTION  = \"B\"\n");

   fprintf (ofp, "   SITE_NAME = \"URF2DAR\"\n\n"); 


   fprintf (ofp, "   SITE_SHAPE = \"P\"\n");
   fprintf (ofp, "   GROUP = POINT_RADIUS_LOC\n");
   fprintf (ofp, "      RADIUS = 6378.0\n");

   fprintf (ofp, "      CENTROID_LAT = %.2f\n",lat);
   fprintf (ofp, "      CENTROID_LON =  %.2f\n",lon);
   fprintf (ofp, "   END_GROUP = POINT_RADIUS_LOC\n\n");

   if (strcmp (prm->pri, "") == 0)
   {
      fprintf (ofp, "   PRIORITY  = \"URGENT\"\n");
   }
   else
   {
      fprintf (ofp, "   PRIORITY  = \"%s\"\n",prm->pri);
   }
   fprintf (ofp, "   ACTIVITY  = \"N\"\n");
   fprintf (ofp, "   DAR_COMMENT = \"Generated automatically from %s\"\n",infile);
   fprintf (ofp, "END_GROUP = DAR_REQUEST\n");
   fprintf (ofp, "END\n");
   fflush(ofp);
   fclose(ofp);
}


float cyc2lon(
   float rev,
   struct s_c0 *c0
)
{

float rem_rev, lon;
float time_orbit, deg_orbit, delta_deg;
   rem_rev = fmod(rev,1.0);

   time_orbit = (float)c0->day_cyc/(float)c0->rev_cyc;
   deg_orbit = -360.0 * time_orbit;
   delta_deg = deg_orbit * rev;

   if ((rem_rev > 0.25) && (rem_rev < 0.75)) 
      delta_deg += 180.0;

   lon =  c0->c0lon + delta_deg;
   while (lon > 180.0) lon -= 360.0;
   while (lon < -180.0) lon += 360.0;

#ifdef DBG
   fprintf(stderr, "T/O%f D/O %f O# %f DDeg %f lon %f\n",
      time_orbit, deg_orbit, rev, delta_deg,lon);
#endif
   return(lon);
}

float cyc2lat(float rev)
{
float rem_rev;
float tlat, lat=0.0;
int quad;

   rem_rev = fmod(rev,1.0);
   tlat = rem_rev * 360;
   quad = ((int)tlat)/90;

   switch (quad)
   {
   case 0: 		/* 0 to 90 lat - ascending */
     lat = tlat;
     break;	
   case 1:		/* 90 to 0 lat - descending */
      lat = 180.0 - tlat;
      break;	
   case 2:              /* 0 to -90 lat - descending */
      lat = 180.0 - tlat;
      break;	
   case 3:              /* -90 to 0 lat - ascending */
      lat = tlat - 360.0;
      break;	
   default:             /* big problem !? */
      fprintf (stderr,"unknown quad for rev %f -> lat %f\n",rev,lat);
      break;
   }
   return(lat);
}

void beam2mode(char *beam, char *mode)
{
char *bmlst[] = { 
"S1", "S2", "S3", "S4", "S5", "S6", "S7",
"W1", "W2", "W3",
"F1", "F2", "F3", "F4", "F5",
"EXTL1",
"EXTH1", "EXTH2", "EXTH3", "EXTH4", "EXTH5",
"Narrow ScanSAR A", "Narrow ScanSAR B",
"Wide ScanSAR A", "Wide ScanSAR B", NULL
};
char *mdlst[] = {
"ST1", "ST2", "ST3", "ST4", "ST5", "ST6", "ST7", 
"WD1", "WD2", "WD3",
"FN1", "FN2", "FN3", "FN4", "FN5",
"EL1",
"EH1", "EH2", "EH3", "EH4", "EH5",
"SNA", "SNB", "SWA", "SWB", NULL
};

int i = 0;

   do {
     if (strcmp(beam, bmlst[i]) == 0)
     {
        strcpy(mode, mdlst[i]);
        return;
     }
     i++;
   } while (mdlst[i] != NULL);
   strcpy(mode,"NONE");
}
