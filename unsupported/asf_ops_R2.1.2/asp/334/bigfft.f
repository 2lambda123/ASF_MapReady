C Alaska SAR Processor (ASP) %W% %E% %U%
        subroutine bigfft(rep,coeftable,repfft,loglen,idir,init)
c
c/* subroutine bigfft(rep,coeftable,repfft,loglen,idir,init) --------
c
c*/
c 8/12/91: pass the idir to do the right direction of FFT
        real rep(1),coeftable(1),repfft(1)
        integer*4   loglen,idir,init,ierr
        integer*4   nfftsize
        nfftsize = 2**loglen
        do i=1,nfftsize*2
           repfft(i) =rep(i)
        end do
        call cfftx(repfft,2,nfftsize,idir,1,coeftable,ierr)
        if(ierr.ne.0)then
            print*,' Error in cfftx routine'
            if(ierr.lt.0) print*,'Invalid value of N'
            if(ierr.eq.-1)print*,'Invalid value of IC'
            if(ierr.eq.-2)print*,'Invalid table'
            stop
        end if
        return
        end
      SUBROUTINE CFFTX (C, IC, N, IDIR, INIT, RTAB, IERR)
c/*      SUBROUTINE CFFTX (C, IC, N, IDIR, INIT, RTAB, IERR) --------
c
C*****  CFFTX   Complex FFT with SIN/COS Table  MATH ADVANTAGE REL 3.0
C
C    ** COPYRIGHT 1987-1988 QUANTITATIVE TECHNOLOGY CORPORATION **
C
C  CALL FORMAT
C
C       CALL CFFTX (C,IC,N,IDIR,INIT,RTAB,IERR)
C
C       where,
C
C       C       Complex input/output vector.
C
C       IC      Integer input stride for vector C.
C
C       N       Integer input element count.
C
C       IDIR    Integer input direction flag:
C                  IDIR > 0  - Perform forward FFT.
C                  IDIR = 0  - No FFT performed.
C                  IDIR < 0  - Perform inverse FFT.
C
C       INIT    Integer input initialization flag: 
C                  INIT <> 0 - Initialize RTAB table.
C                  INIT =  0 - No initialization.
C
C       RTAB    Real input/output vector of length N+1.
C                  Input when INIT = 0.
C                  Output when INIT <> 0.
C
C       IERR    Integer output completion code:
C                  IERR =  0  - Normal completion.
C                  IERR >  0  - Invalid value of N (see below).
C                  IERR = -1  - Invalid value of IC (IC<2).
C                  IERR = -2  - Invalid tables (see below).
C
C  DESCRIPTION
C
C       This routine performs either a forward or inverse
C       complex FFT on the data stored in vector C, depending
C       on the value of IDIR.  
C
C       If IDIR > 0, the routine performs a forward FFT.  The results
C       are overlaid on vector C.  These results are not properly
C       scaled and may be scaled using CFFTSS to multiply by 1/N.
C
C       If IDIR < 0, the routine performs an inverse FFT.  The results
C       are overlaid on vector C and do not need to be scaled.
C
C       If INIT is nonzero, then a table corresponding to the specific
C       value of N is generated, stored and returned in the vector RTAB.
C       If INIT = 0, RTAB is not generated, thus a table previously
C       generated must be supplied as an input in RTAB.  A sine/cosine
C       table generated by this routine may also be used as input 
C       to the Math Advantage routine RFFTX.
C
C       When RTAB is generated, the value of N is stored in the
C       first element of the table.  In subsequent calls with INIT = 0,
C       the input value of N is checked against the first element of
C       RTAB.  If N is greater than the first element from RTAB then
C       the table is declared to be invalid.
C
C       If both IDIR and INIT are nonzero, then the table generation
C       occurs prior to performing the FFT.  If INIT is nonzero and
C       IDIR is zero, the table generation occurs but no FFT is performed.
C       If both IDIR and INIT are zero, the only action is the validity
C       checking of N, IC, and the input table RTAB.
C
C       N must be a power of two.  If the value of N is invalid, then
C       the value returned in IERR is the smallest valid length that
C       is greater than N; i.e., IERR is set to the smallest power of
C       two > N.
C
C       Refer to Appendix B for machine dependent notes.
C
C
C  REFERENCE
C  
C       J. W. Cooley and J. W. Tukey.  1965.  An algorithm for
C       the machine calculation of complex Fourier Series.
C       Math. Comp., Vol. 19,  pp. 297-301.
C  
C       G. D. Bergland.  1969.  A radix-eight fast Fourier
C       transform subroutine for real-valued series.  IEEE
C       Trans. on Audio and Electroacoust., Vol. AU-17,  pp.
C       138-144.
C  
C       E. O. Brigham.  1974.  The fast Fourier transform.
C       Englewood Cliffs NJ: Prentice-Hall.
C
C
C  EXAMPLE
C
C       CALL CFFTX(C,2,8,1,1,RTAB,IERR)
C
C       Input Operands:
C
C       C = (1.0, 0.0)
C           (1.0, 0.0)
C           (1.0, 0.0)
C           (1.0, 0.0)
C           (1.0, 0.0)
C           (1.0, 0.0)
C           (1.0, 0.0)
C           (1.0, 0.0)
C
C       Output Operands:
C
C       C = (8.0, 0.0)
C           (0.0, 0.0)
C           (0.0, 0.0)
C           (0.0, 0.0)
C           (0.0, 0.0)
C           (0.0, 0.0)
C           (0.0, 0.0)
C           (0.0, 0.0)
C
C       RTAB =  8.000000000
C               0.707106769
C               1.000000000
C               0.707106769
C               0.000000000
C              -0.707106769
C              -1.000000000
C              -0.707106769
C               0.000000000
C
C       IERR = 0
C
C  HISTORY
C         1) Feb 88     B. D. Leback    Original.
C*/
C
C
      REAL    C(1), RTAB(1)
      INTEGER IC, N, IDIR, INIT, IERR, NFFT, NT
C
C-----------------------------------------------------------------------
C
      IERR =  0
C
C  CHECK THAT N IS A POWER OF 2
C
      NFFT = 1
      DO 10 I = 1, 15
         NFFT = NFFT + NFFT
         IF (NFFT .GT. N) THEN
            IERR = NFFT
            GO TO 800
         ENDIF
         IF (NFFT .EQ. N) GO TO 20
   10 CONTINUE
C
C  CHECK VALIDITY OF STRIDE
C
   20 CONTINUE
      IF (IC .LT. 2) THEN
         IERR = -1
         GO TO 800
      ENDIF
C
C  CHECK VALIDITY OF TABLES
C
      IF (INIT .EQ. 0) THEN
         IF (N .GT. IFIX( RTAB(1) )) THEN
            IERR = -2
            GO TO 800
         ELSE
            NT = IFIX( RTAB(1) )
         ENDIF
      ELSE
         CALL QTC047 (RTAB(2), N)
         RTAB(1) = FLOAT(N)
         NT = N
      ENDIF
C
C  PERFORM FFT
C
      IF (IDIR .EQ. 0) GO TO 800
C
      CALL QTC046 (C(1), N, IC, IDIR, RTAB(2), NT)
C
C  EXIT ROUTINE
C
  800 CONTINUE
      RETURN
      END
      SUBROUTINE QTC010(NTHPO,CR0,CR1,DI)
c/*      SUBROUTINE QTC010(NTHPO,CR0,CR1,DI)  --------------------
C
C   *****  QTC010  MATH ADVANTAGE Private Subroutine R2TX
C   ***** RADIX 2 ITERATION SUBROUTINE            *****
C
C    ** COPYRIGHT 1984-1985 QUANTITATIVE TECHNOLOGY CORPORATION **
C*/
      INTEGER IC,NTHPO,KR,KI,DI
      REAL CR0(1),CR1(1)
      REAL R1,FI1
      IF (NTHPO.LE.0) GOTO 40
      DO 10 IC=1,NTHPO,2
        KI = (IC-1) * DI + 2
        KR = KI - 1
        R1 = CR0(KR) + CR1(KR)
        CR1(KR) = CR0(KR) - CR1(KR)
        CR0(KR) = R1
        FI1 = CR0(KI) + CR1(KI)
        CR1(KI) = CR0(KI) - CR1(KI)
        CR0(KI) = FI1
10    CONTINUE
40    RETURN
      END
      SUBROUTINE QTC013(NTHPO,CR0,CR1,CR2,CR3,DI)
C/*      SUBROUTINE QTC013(NTHPO,CR0,CR1,CR2,CR3,DI)  ----------
C
C   *****  QTC013  MATH ADVANTAGE Private Subroutine R4TX
C   ***** RADIX 4 ITERATION SUBROUTINE            *****
C
C    ** COPYRIGHT 1984-1985 QUANTITATIVE TECHNOLOGY CORPORATION **
C*/
      INTEGER IC,NTHPO,KR,KI,DI
      REAL CR0(1),CR1(1),CR2(1),CR3(1)
      REAL R1,R2,R3,R4,FI1,FI2,FI3,FI4
      IF (NTHPO.LE.0) GOTO 40
      DO 10 IC=1,NTHPO,4
        KI = (IC-1) * DI + 2
        KR = KI - 1
        R1 = CR0(KR) + CR2(KR)
        R2 = CR0(KR) - CR2(KR)
        R3 = CR1(KR) + CR3(KR)
        R4 = CR1(KR) - CR3(KR)
        FI1 = CR0(KI) + CR2(KI)
        FI2 = CR0(KI) - CR2(KI)
        FI3 = CR1(KI) + CR3(KI)
        FI4 = CR1(KI) - CR3(KI)
        CR0(KR) = R1 + R3
        CR0(KI) = FI1 + FI3
        CR1(KR) = R1 - R3
        CR1(KI) = FI1 - FI3
        CR2(KR) = R2 - FI4
        CR2(KI) = FI2 + R4
        CR3(KR) = R2 + FI4
        CR3(KI) = FI2 - R4
10    CONTINUE
40    RETURN
      END
      SUBROUTINE QTC046(C,N,DI,IFLG,RTBL,NT)
C/*      SUBROUTINE QTC046(C,N,DI,IFLG,RTBL,NT)  -----------
C
C   *****  QTC046  MATH ADVANTAGE Private Subroutine    CFFTBL
C   ***** EXPANDED COMPLEX-TO-COMPLEX FFT WITH TABLE ******
C ---- USES DI AS INCREMENT (NORMALLY 2),
C       REAL ELEMENT IS AT (IA-1)*DI/2+1, IMAGINARY AT (IA-2)*DI/2+2
C
C    ** COPYRIGHT 1984-1985 QUANTITATIVE TECHNOLOGY CORPORATION **
C*/
      INTEGER N,DI,IFLG,NFFT
      REAL C(1)
      REAL R,FI
      INTEGER M,IA,N2POW,NTHPO,N8POW
      INTEGER ID(15),L1,L2,L3,L4,L5,L6,L7,L8,L9,L10,L11,L12,L13,L14,L15
      INTEGER NXTLT,IPASS,LENGT,IB,IJ,IJ2,JI,JI2
      INTEGER J1,J2,J3,J4,J5,J6,J7,J8,J9,J10,J11,J12,J13,J14
      INTEGER NEWI, NSPAN, DIOV2, IINC
      EQUIVALENCE (L15,ID(1)),(L14,ID(2)),(L13,ID(3)),(L12,ID(4)),
     1      (L11,ID(5)),(L10,ID(6)),(L9,ID(7)),(L8,ID(8)),(L7,ID(9)),
     2      (L6,ID(10)),(L5,ID(11)),(L4,ID(12)),(L3,ID(13)),
     3      (L2,ID(14)),(L1,ID(15))
C      DATA PI2,P7 /6.28318531,0.707106781/
      IF (N.LE.1) GOTO 170
      NFFT = 1
      DO 10 IA=1,15
        M = IA
        NFFT = NFFT+NFFT
        IF (NFFT.EQ.N) GO TO 20
        IF (NFFT.GT.N) GOTO 170
10    CONTINUE
20    N2POW = M
      NTHPO = NFFT
      DIOV2 = DI/2
      IF (IFLG.EQ.-1) GOTO 40
        DO 30 IA=2,NTHPO+NTHPO,2
          NEWI = (IA-2)*DIOV2+2
          C(NEWI) = -C(NEWI)
30      CONTINUE
40    N8POW = N2POW/3
      IF (N8POW.EQ.0) GOTO 60
C
C     RADIX 8 PASSES, IF ANY.
C
      IINC = NT / N
      DO 50 IPASS=1,N8POW
        NXTLT = 2**(N2POW-3*IPASS)
        NSPAN = NXTLT * DI
        LENGT = 8*NXTLT
        CALL QTC048(NXTLT,NTHPO,LENGT,C(1),C(NSPAN+1),C(2*NSPAN+1),
     1       C(3*NSPAN+1),C(4*NSPAN+1),C(5*NSPAN+1),C(6*NSPAN+1),
     2       C(7*NSPAN+1),DI,RTBL,IINC,NT)
        IINC = 8*IINC
50    CONTINUE
C
C     IS THERE A FOUR FACTOR LEFT?
C
60    IF (N2POW-3*N8POW-1) 90,70,80
C
C     GO THROUGH THE BASE 2 ITERATION
C
70    CALL QTC010(NTHPO,C(1),C(DI+1),DI)
      GOTO 90
C
C     GO THROUGH THE BASE 4 ITERATION
C
80    CALL QTC013(NTHPO,C(1),C(DI+1),C(DI+DI+1),C(DI+DI+DI+1),DI)
C
90    DO 110 IB=1,15
        ID(IB) = 1
        IF (IB-N2POW) 100, 100, 110
100     ID(IB) = 2**(N2POW+1-IB)
110   CONTINUE
C
C     BIT-REVERSE STEPS:
C
      IJ = 1
      DO 130 J1=1,L1
      DO 130 J2=J1,L2,L1
      DO 130 J3=J2,L3,L2
      DO 130 J4=J3,L4,L3
      DO 130 J5=J4,L5,L4
      DO 130 J6=J5,L6,L5
      DO 130 J7=J6,L7,L6
      DO 130 J8=J7,L8,L7
      DO 130 J9=J8,L9,L8
      DO 130 J10=J9,L10,L9
      DO 130 J11=J10,L11,L10
      DO 130 J12=J11,L12,L11
      DO 130 J13=J12,L13,L12
      DO 130 J14=J13,L14,L13
      DO 130 JI=J14,L15,L14
        IF (IJ-JI) 120,130,130
120       IJ2 = (IJ-1) * DI + 2
          JI2 = (JI-1) * DI + 2
          R = C(IJ2-1)
          FI = C(IJ2)
          C(IJ2-1) = C(JI2-1)
          C(IJ2) = C(JI2)
          C(JI2-1) = R
          C(JI2) = FI
130     IJ = IJ + 1
C
      IF (IFLG.EQ.-1) GOTO 170
        DO 140 IA=2,NTHPO+NTHPO,2
          NEWI = (IA-2)*DIOV2+2
          C(NEWI) = -C(NEWI)
140     CONTINUE
170   RETURN
      END
      SUBROUTINE QTC047(TBL,N)
C/*      SUBROUTINE QTC047(TBL,N)  ------------------------
C
C   *****  QTC047  MATH ADVANTAGE Private Subroutine     GXTBL
C   ***** GENERATE SIN/COS TABLE FOR CFFTX AND RFFTX  *****
C
C    ** COPYRIGHT 1987-1988 QUANTITATIVE TECHNOLOGY CORPORATION **
C*/
      REAL    TBL(1),TWOPI,TPION,CCNST(8)
      INTEGER N,IC,IINC,I,J,N1O8,N7O8
C
      DATA TWOPI / 6.28318531 /
      DATA CCNST / 0.707106781,  1.0,  0.707106781, 0.0, 
     1            -0.707106781, -1.0, -0.707106781, 0.0 /
C
      IF (N .GT. 8) GOTO 20
        IINC = 8 / N
        IC   = 2 - (N / 8)
        DO 10 I = 1, N
          TBL(I) = CCNST(IC)
          IC     = IC + IINC
   10   CONTINUE
        GO TO 100
C
   20 CONTINUE
      J = 1
      N1O8 = N / 8
      N7O8 = N * 7 / 8
      TPION = TWOPI / FLOAT(N)
      DO 30 I = -N1O8, N7O8-1
        TBL(J) = COS( FLOAT(I) * TPION)
        J = J + 1
   30 CONTINUE
C
  100 CONTINUE
      RETURN
      END
      SUBROUTINE QTC048(NXTLT,NTHPO,LENGT,CR0,CR1,CR2,CR3,CR4,CR5,
     +                 CR6,CR7,DI,RTBL,IINC,NT)
C/*   SUBROUTINE QTC048(NXTLT,NTHPO,LENGT,CR0,CR1,CR2,CR3,CR4,CR5, -----
C     +                 CR6,CR7,DI,RTBL,IINC,NT)
C
C   *****  QTC048  MATH ADVANTAGE Private Subroutine R8TBL
C   ***** RADIX 8 ITERATION SUBROUTINE            *****
C
C    ** COPYRIGHT 1984-1985 QUANTITATIVE TECHNOLOGY CORPORATION **
C*/
      INTEGER NTHPO,NXTLT,LENGT,IB,IC,KR,KI,DI,IINC,NT
      REAL CR0(1),CR1(1),CR2(1),CR3(1),CR4(1),CR5(1),
     +     CR6(1),CR7(1),RTBL(1)
      REAL P7,TR,TI
      REAL C1,C2,C3,C4,C5,C6,C7
      REAL S1,S2,S3,S4,S5,S6,S7
      REAL AR0,AR1,AR2,AR3,AR4,AR5,AR6,AR7
      REAL AI0,AI1,AI2,AI3,AI4,AI5,AI6,AI7
      REAL BR0,BR1,BR2,BR3,BR4,BR5,BR6,BR7
      REAL BI0,BI1,BI2,BI3,BI4,BI5,BI6,BI7
      INTEGER IC0,ICC,IS0,ISS,ISTR
C
      IF (NXTLT.LE.0) GOTO 40
      P7 =  SQRT(0.5)
      IC0 = 1 + (NT / 8)
      IS0 = 1 + (NT * 7 / 8)
      ISTR = IINC
      DO 30 IB=1,NXTLT
        IF (NTHPO.LT.IB) GOTO 40
        DO 20 IC=IB,NTHPO,LENGT
          KI = (IC-1) * DI + 2
          KR = KI - 1
          AR0 = CR0(KR) + CR4(KR)
          AR1 = CR1(KR) + CR5(KR)
          AR2 = CR2(KR) + CR6(KR)
          AR3 = CR3(KR) + CR7(KR)
          AR4 = CR0(KR) - CR4(KR)
          AR5 = CR1(KR) - CR5(KR)
          AR6 = CR2(KR) - CR6(KR)
          AR7 = CR3(KR) - CR7(KR)
          AI0 = CR0(KI) + CR4(KI)
          AI1 = CR1(KI) + CR5(KI)
          AI2 = CR2(KI) + CR6(KI)
          AI3 = CR3(KI) + CR7(KI)
          AI4 = CR0(KI) - CR4(KI)
          AI5 = CR1(KI) - CR5(KI)
          AI6 = CR2(KI) - CR6(KI)
          AI7 = CR3(KI) - CR7(KI)
          BR0 = AR0 + AR2
          BR1 = AR1 + AR3
          BR2 = AR0 - AR2
          BR3 = AR1 - AR3
          BR4 = AR4 - AI6
          BR5 = AR5 - AI7
          BR6 = AR4 + AI6
          BR7 = AR5 + AI7
          BI0 = AI0 + AI2
          BI1 = AI1 + AI3
          BI2 = AI0 - AI2
          BI3 = AI1 - AI3
          BI4 = AI4 + AR6
          BI5 = AI5 + AR7
          BI6 = AI4 - AR6
          BI7 = AI5 - AR7
          CR0(KR) = BR0 + BR1
          CR0(KI) = BI0 + BI1
          IF (IB.LE.1) GOTO 10
            CR1(KR) = C4 * (BR0 - BR1) + S4 * (BI0 - BI1)
            CR1(KI) = C4 * (BI0 - BI1) - S4 * (BR0 - BR1)
            CR2(KR) = C2 * (BR2 - BI3) + S2 * (BI2 + BR3)
            CR2(KI) = C2 * (BI2 + BR3) - S2 * (BR2 - BI3)
            CR3(KR) = C6 * (BR2 + BI3) + S6 * (BI2 - BR3)
            CR3(KI) = C6 * (BI2 - BR3) - S6 * (BR2 + BI3)
            TR = P7 * (BR5 - BI5)
            TI = P7 * (BR5 + BI5)
            CR4(KR) = C1 * (BR4 + TR) + S1 * (BI4 + TI)
            CR4(KI) = C1 * (BI4 + TI) - S1 * (BR4 + TR)
            CR5(KR) = C5 * (BR4 - TR) + S5 * (BI4 - TI)
            CR5(KI) = C5 * (BI4 - TI) - S5 * (BR4 - TR)
            TR = -P7 * (BR7 + BI7)
            TI = P7 * (BR7 - BI7)
            CR6(KR) = C3 * (BR6 + TR) + S3 * (BI6 + TI)
            CR6(KI) = C3 * (BI6 + TI) - S3 * (BR6 + TR)
            CR7(KR) = C7 * (BR6 - TR) + S7 * (BI6 - TI)
            CR7(KI) = C7 * (BI6 - TI) - S7 * (BR6 - TR)
            GOTO 20
C       HERE WHEN IB = 1:
10          CR1(KR) = BR0 - BR1
            CR1(KI) = BI0 - BI1
            CR2(KR) = BR2 - BI3
            CR2(KI) = BI2 + BR3
            CR3(KR) = BR2 + BI3
            CR3(KI) = BI2 - BR3
            TR = P7 * (BR5 - BI5)
            TI = P7 * (BR5 + BI5)
            CR4(KR) = BR4 + TR
            CR4(KI) = BI4 + TI
            CR5(KR) = BR4 - TR
            CR5(KI) = BI4 - TI
            TR = -P7 * (BR7 + BI7)
            TI = P7 * (BR7 - BI7)
            CR6(KR) = BR6 + TR
            CR6(KI) = BI6 + TI
            CR7(KR) = BR6 - TR
            CR7(KI) = BI6 - TI
C         ENDIF
20      CONTINUE
        IF (IB.EQ.NXTLT) GOTO 30
           ICC = IC0 + ISTR
           C1 = RTBL(ICC)
           ICC = ICC + ISTR
           C2 = RTBL(ICC)
           ICC = ICC + ISTR
           C3 = RTBL(ICC)
           ICC = ICC + ISTR
           C4 = RTBL(ICC)
           ICC = ICC + ISTR
           C5 = RTBL(ICC)
           ICC = ICC + ISTR
           C6 = RTBL(ICC)
           ICC = ICC + ISTR
           C7 = RTBL(ICC)
           ISS = IS0 - ISTR
           S1 = RTBL(ISS)
           ISS = ISS - ISTR
           S2 = RTBL(ISS)
           ISS = ISS - ISTR
           S3 = RTBL(ISS)
           ISS = ISS - ISTR
           S4 = RTBL(ISS)
           ISS = ISS - ISTR
           S5 = RTBL(ISS)
           ISS = ISS - ISTR
           S6 = RTBL(ISS)
           ISS = ISS - ISTR
           S7 = RTBL(ISS)
           ISTR = ISTR + IINC
30    CONTINUE
40    RETURN
      END
