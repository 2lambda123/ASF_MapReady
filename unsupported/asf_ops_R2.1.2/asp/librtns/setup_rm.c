/* Alaska SAR Processor (ASP) %W% %E% %U% */
/*  setup_rm.c - This module sets up the control registers on
    both of the Range Migration Boards.  It contains four
    functions:

    setup_rm   - The control registers of both boards are
		 set.  The imag_real control bit in
		 register 0 of each board, is set
		 automatically.  The data propagation
		 delay is returned.
    rm_ovf_reset - Resets overflow flags.
    get_rm_stat- This routine gets the values of the
		 read only status registers.  The data
		 propagation delay is also returned.
    get_rm_del - Returns the propagation delay based on
		 the current control register contents.
    setup_rm_mem - Loads Range Migration multibus memory.

    The calling sequences and command line arguments for these
    functions are explained below.

int setup_rm(enable,test,four_lk,format,rmupdate,lpow,wsel)
    
    The command line arguments are:
    enable    - Each nibble enables (1) or bypasses (0) the
		  corresponding functional block:
		0x1000 = Inverse Mux
                0x0100 = Unscrambler
                0x0010 = Range Migration Memory
                0x0001 = Range Migration Path
		NOTE: To enable interpolation, both the 3rd and
		  4th nibbles must be 1 (i.e., 0x0011).
		  If nibble 4 is 0, the addresses being generated by
		  the path generator will be output on the data bus.
		  If nibble 4 is 1 and nibble 3 is 0, the output of the
		  unscrambler block will be output on the data bus.
    test      - 1 = Send board output to the test bus
    four_lk   - 1 = Four Look input data
		0 = One Look input data
    format    - 1 = Divide the interpolator output by 2
    rmupdate  - 1 = Use CTC handshake to update Range Constant Memories
                0 = Run free (update said memories uncoditionally)
    lpow      - Line length in power of 2 notation
    wsel      - Select the set of interpolation weighting coefficients
    Propagation delay is returned.

int get_rm_stat(overflow,readrm,request)
    Arguments are passed by address.
    overflow - Frame input before previous frame output
    readrm   - Data being read from Range Migration Memory
    request  - Request lines from Corner Turn Memory
    Propagation delay is returned.

int get_rm_del()
    Propagation delay is returned.  cregs must be moved to the
    board before the delay is valid.

void setup_rm_mem(frmd_coarse,fine,valn_kl,val2d,vala,lines_out)
    frmd_coarse - 8k x 14 memory
		  bit 13 = Flag that tells when  frame has
			   been read out
                  bits 12..0 = Defines when to begin reading
    fine        - 8k x 16 memory
		  Constant in path generation
    valn_kl     - 2k x 16 memory
		  Path counter initialization
    val2d       - 2k x 16 memory
		  Path parameter
    vala        - 2k x 16 memory
		  Path parameter
    lines_out   - Number of lines which rm will output

-----------------------------------------------------------------
*/

#include <aspdecl.h>

static short int   cregs[2];


/* get_rm_del() --------------------------------------------------------
	This routine gets the data propagation delay through
	the RM Board based on the current register settings.
*/
int get_rm_del()
{
    int    delay;
    int    enableuns, enablememory;
    int    lpow, linelength;

    /* Get cregs from board */
    asp_read( RLOC_RMR<<1, &mb.w[RLOC_RMR], 2 );
    cregs[0] = mb.w[RLOC_RMR];

    /* Decode relevant values from cregs */
    enableuns = (cregs[0] >> 14) & 0x1;
    enablememory = (cregs[0] >> 13) & 0x1;
    lpow = cregs[0] & 0xf;
    linelength = 0x1 << lpow;

    delay = 7 + (!enablememory * 8) + (!enableuns * linelength);
    return(delay);
}

/* setup_rm(enable,test,four_lk,format,rmupdate,lpow,wsel) ------------
	This routine sets up the control registers for both
	RM Boards.
*/
int setup_rm(enable,test,four_lk,format,rmupdate,lpow,wsel)
int   enable, test, four_lk, format, rmupdate;
int   lpow, wsel;
{
    int   i, trigger;
    int   enablemux, enableuns, enablememory, enablepath;

    /* Expand condensed control */
    enablemux =    ((enable & 0xf000) != 0);
    enableuns =    ((enable & 0x0f00) != 0);
    enablememory = ((enable & 0x00f0) != 0);
    enablepath =   ((enable & 0x000f) != 0);

    /* Limit arguments */
    test &= 0x1;
    four_lk &= 0x1;
    format &= 0x1;
    rmupdate &= 0x1;
    lpow &= 0xf;
    wsel &= 0x1f;

    /* Default cregs[] - spare(1) bit mask */
    cregs[0] = 0x0060;
    cregs[1] = 0x1f00;

    /* Set up the register bits */
    cregs[0] |= (enablemux << 15) | (enableuns << 14);
    cregs[0] |= (enablememory << 13) | (enablepath << 12);
    cregs[0] |= (!test << 11) | (!four_lk << 9) | (format << 8);
    cregs[0] |= (rmupdate << 7) | lpow;
    cregs[1] |= wsel;

    /* Move the control registers to the real board */
    mb.w[RLOC_RMR] = cregs[0];
    mb.w[RLOC_RMR + 1] = cregs[1];
    asp_write( RLOC_RMR<<1, &mb.w[RLOC_RMR], 4 );

    /* Modify control registers for imag board */
    cregs[0] |= 0x1 << 10;

    /* Move the control register to the imag board */
    mb.w[RLOC_RMI] = cregs[0];
    mb.w[RLOC_RMI + 1] = cregs[1];
    asp_write( RLOC_RMI<<1, &mb.w[RLOC_RMI], 4 );

    /* Set trigger count */
    trigger = get_rm_del();
    return(trigger);
}

/* rm_ovf_reset() ---------------------------------------------------
    	This function resets memory overflow flags 
    	on both Range Migration Boards.
*/
rm_ovf_reset ()
{
    asp_read( RLOC_RMR<<1, &mb.w[RLOC_RMR], 2 );
    mb.w[RLOC_RMR] &= 0xffef;    /* Bring reset overflow bit low */
    asp_write( RLOC_RMR<<1, &mb.w[RLOC_RMR], 2 );
    asp_read( RLOC_RMI<<1, &mb.w[RLOC_RMI], 2 );
    mb.w[RLOC_RMI] &= 0xffef;
    asp_write( RLOC_RMI<<1, &mb.w[RLOC_RMI], 2 );
    mb.w[RLOC_RMR] |= 0x0010;    /* Bring it back high */
    asp_write( RLOC_RMR<<1, &mb.w[RLOC_RMR], 2 );
    mb.w[RLOC_RMI] |= 0x0010;
    asp_write( RLOC_RMI<<1, &mb.w[RLOC_RMI], 2 );
}

/* setup_rm_mem(frmd_coarse,fine,valn_kl,val2d,vala,lines_out) ------
    	This function loads the Multibus memories
    	on both Range Migration Boards.
*/
setup_rm_mem(frmd_coarse,fine,valn_kl,val2d,vala,lines_out)
short int frmd_coarse[8192]; /* Framedone bit + coarse offset */
short int fine[8192];        /* Fine path offset */
short int valn_kl[2048];     /* Path counter initialization */
short int val2d[2048];       /* Path parameter */
short int vala[2048];        /* Path parameter */
int lines_out;               /* number of lines out of RM */
{
    int   i, j, mloc[2], pid;
    int   mloc_fine, mloc_nkl, mloc_2d, mloc_a;

    /* Save current control computer page ID */
    pid = mb.w[RLOC_REP];

    /* Set pid for RM Multibus memories */
    mb.w[RLOC_REP] = PID_RM;

    mloc[0] = MLOC_RMR >> 1;
    mloc[1] = MLOC_RMI >> 1;

    /* Load each board memory */

    if (lines_out > 8191) {
	printf (" setup_rm: lines_out too big: setting to 8191!\n");
	lines_out = 8191;
    }
    for (j = 0; j <= 1; j++) {
        mloc_fine = mloc[j] + 8192;
        mloc_nkl = mloc_fine + 8192;
        mloc_2d = mloc_nkl + 2048;
        mloc_a = mloc_2d + 2048;

        /* Load memories */
	bcopy( frmd_coarse, &mb.w[mloc[j]], 16384 );
	bcopy( fine, &mb.w[mloc_fine], 16384 );
        for (i = 0; i < 8192; i++) {
	    if (i < lines_out)    /* setting FRDN' */
		mb.w[mloc[j] + i] |= 0x8000;
            if (i < (lines_out - 15))    /* setting NEAREND' */
		mb.w[mloc[j] + i] |= 0x4000;
        }
	bcopy( valn_kl, &mb.w[mloc_nkl], 4096 );
	bcopy( val2d, &mb.w[mloc_2d], 4096 );
	bcopy( vala, &mb.w[mloc_a], 4096 );
    }
    asp_write( MEM_RMR, &mb.w[mloc[0]], 16384+16384+4096+4096+4096 );
    asp_write( MEM_RMI, &mb.w[mloc[1]], 16384+16384+4096+4096+4096 );

    /* Restore pid */
    mb.w[RLOC_REP] = pid;
}

/* get_rm_stat (overflow, readrm, request) -----------------------------
	This routine returns the settings of the RM board read-only
	status bits.
*/
get_rm_stat (overflow, readrm, request)
int *overflow, *readrm, *request;
{
    int c1, c2;

    asp_read( (RLOC_RMR+1)<<1, &mb.w[RLOC_RMR+1], 2 );
    asp_read( (RLOC_RMI+1)<<1, &mb.w[RLOC_RMI+1], 2 );
    c1 = mb.w[RLOC_RMR + 1] & 0xffff;
    c2 = mb.w[RLOC_RMI + 1] & 0xffff;
    *overflow = ((c1 & (1 << 15)) == 0) | ((c2 & (1 << 15)) == 0);
    *readrm   = ((c1 & (1 << 14)) != 0) | ((c2 & (1 << 14)) != 0);
    *request  = ((c1 & (1 << 13)) == 0) | ((c2 & (1 << 13)) == 0);
}
