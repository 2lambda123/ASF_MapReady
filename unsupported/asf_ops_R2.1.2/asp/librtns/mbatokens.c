/* Alaska SAR Processor (ASP) %W% %E% %U% */
/* mbatokens.c -- routines to read a text file and break it into tokens */

#include <stdio.h>
#include <unistd.h>

static FILE *fp;

int toupper_sw = 1;		/* 1 = convert lower case to upper */
char token_separator;		/* holds last seen token separator */
static char ts[100] = "=";	/* token separator table */
static int col = 0;		/* current token place in line */
				/* 1 = first token on line */
				/* 2 = token in middle of line */
				/* 3 = token at end of line */
				/* 0 = beginning or end of file */

/* set_separators (s) --------------------------------------------------
	This routine sets up a user-defined set of token separators for
	use by the next_token routine.
*/
set_separators(s)
	char *s;
{
	char *strcpy();

	strcpy(ts,s);
}

/* open_file(name,ext) -------------------------------------------------
	This routine tries to open a file for input.  If the open is
	successful, the routine returns 1, otherwise the routine 
	returns 0.  The filename is generated by concatenating name 
	and ext.
*/
open_file(name,ext)
	char *name,*ext;
{
	char filnam[80];
	char *strcat(),*strcpy();

	strcat(strcpy(filnam,name),ext);
    /*
	printf("opening file %s\n",filnam);
    */
	if ((fp = fopen(filnam,"r")) == NULL)
	    return(0);
	col = 0;
	return(1);
}

/* close_file() --------------------------------------------------------
	This routine closes a file previously opened by open_file.
*/
close_file()
{
	if (fp != NULL)
	    fclose(fp);
}

/* move_fp(from,to)-----------------------------------------------------
	This routine moves the file pointer relative to the
	location specified by from.  It is moved 'to' number of
	bytes.  'from' is a character string and may be:
	"start", "current" or "end".  'to' may be a negative or
	positive integer.  The routine returns the number of
	bytes moved.
*/
int move_fp(from,to)
char    *from;    /* Can be "start", "current" or "end" */
int     to;       /* Number of bytes to move, negative or positive */
{
    int    bytes;   /* Number of bytes pointer is moved */

    switch(*from) {
	case 's':      /* Move file pointer to start of file */
	    if (to < 0)  /* Negative move from start impossible */
		return(0);
	    fseek(fp,to,SEEK_SET);  /* Move pointer */
            bytes = ftell(fp);          /* Bytes moved */
	    break;
        case 'c':      /* Move file point relative to current pos */
	    bytes = ftell(fp);        /* Current position */
	    fseek(fp,to,SEEK_CUR);    /* Move pointer */
	    bytes = ftell(fp) - bytes;  /* Bytes moved */
	    break;
        case 'e':      /* Move file pointer relative to end */

            if (to > 0)  /* Positive move from end impossible */
		return(0);
            fseek(fp,0,SEEK_END);  /* move pointer to end*/
            bytes = ftell(fp);     /* End position */
	    fseek(fp,-to,SEEK_END);  /* Move pointer to new pos */
	    bytes = bytes - ftell(fp);  /* Bytes moved */
	    break;
        default:  return(0);  /* Illegal commmand */
    }
    return(bytes);  /* Return bytes move */
}

/* scan_for(t) ---------------------------------------------------------
	This routine scans the input file for a token which is at the
	front of a line of input, and matches the incoming token t.  If
	a match is found, the routine returns 1, otherwise 0.  If 0 is
	returned, the input file is at EOF.
*/
scan_for(t)
	char *t;		/* string to match to */
{
	char s[80];		/* hold area for returned token */

	while (next_head(s)) {
	    if (strcmp(s,t) == 0)
		return(1);
	}
	return(0);
}

/* find_token(t)--------------------------------------------------------
	This routine scans the input file for a token that matches
	the incoming token t.  The token may be positioned anywhere
	in the file.  If a match is found, the routine returns 1,
	otherwise 0.  If 0 is returned, the input file is at EOF.
*/
find_token(t)
	char *t;                 /* string to match to */
{
	char s[80];
	int  position;

	position = ftell(fp);   /* Get current file pointer pos */
	while (next_token(s) != 0) {  /* Not EOF */
	    if (strcmp(s,t) == 0)
		return(1);
        }
	if (position != 0)      /* Didn't start a beginning */
	{
	    fseek(fp,0,SEEK_SET);   /* Move fp to beginning */
	    while (next_token(s) != 0) {  /* Search again */
		if (strcmp(s,t) == 0)
		    return(1);
            }
        }
	return(0);
}

/* next_head(t) --------------------------------------------------------
	This routine reads the next token which is at the front of a 
	line, and returns the token in t.  The routine also returns 1
	if a token is returned, or 0 if at end of file.
*/
next_head(t)
	char *t;	/* string to contain the returned token */
{
	int n = 1;

	while ((n = next_token(t)) > 1)
	    ;
	return(n);
}

/* get_int(i) ----------------------------------------------------------
	This routine reads the next token from the input stream, and
	converts it to an integer value in i.  The value returned by
	next_token is returned as the value of this routine as well.
	The token should be an ascii-coded decimal value, or an ascii-
	coded hex value preceded by "0x", or an ascii-coded binary
	value preceded by "0b".
*/
get_int(i)
	int *i;		/* return variable for integer value */
{
	int n;		/* holds return value of next_token */
	char t[80];	/* holds token before conversion */
	char c;
	int neg;

	neg = ((c = getc(fp)) == '-');
	ungetc(c,fp);
	n = next_token(t);
	if (t[0] == '0' && toupper(t[1]) == 'X')
	    sscanf(&t[2],"%x",i);
	else if (t[0] == '0' && toupper(t[1]) == 'B')
	    *i = abtoi(&t[2]);
	else
	    *i = atoi(t);
	if (neg)
	    *i = -(*i);
	return(n);
}

/* abtoi(t) ------------------------------------------------------------
	This routine converts the ascii string in t into an integer
	value, and returns that value.  The conversion stops at the
	first character which is not a 0 or 1.
*/
abtoi(t)
	char *t;
{
	int i = 0;

	while (*t == '0' || *t == '1')
	    i = (i << 1) + (*t++ == '1');
	return (i);
}

/* get_hex(i) ----------------------------------------------------------
	This routine reads the next token from the input stream, and
	converts it to an integer value in i.  The value returned by
	next_token is returned as the value of this routine as well.
	The token should be an ascii-coded hex value.
*/
get_hex(i)
	int *i;		/* return variable for integer value */
{
	int n;		/* holds return value of next_token */
	char t[80];	/* holds token before conversion */
	char c;
	int neg;

	neg = ((c = getc(fp)) == '-');
	ungetc(c,fp);
	n = next_token(t);
	if (t[0] == '0' && toupper(t[1]) == 'X')
	    sscanf(&t[2],"%x",i);
	else
	    sscanf(t,"%x",i);
	if (neg)
	    *i = -(*i);
	return(n);
}

/* get_binary(i) -------------------------------------------------------
	This routine reads the next token from the input stream, and
	converts it to an integer value in i.  The value returned by
	next_token is returned as the value of this routine as well.
	The token should be an ascii-coded binary value.
*/
get_binary(i)
	int *i;		/* return variable for integer value */
{
	int n;		/* holds return value of next_token */
	char t[80];	/* holds token before conversion */
	char c;
	int neg;
	int j;

	neg = ((c = getc(fp)) == '-');
	ungetc(c,fp);
	n = next_token(t);
	j = (t[0] == '0' && toupper(t[1]) == 'B') ? 2 : 0;
	*i = abtoi(&t[j]);
	if (neg)
	    *i = -(*i);
	return(n);
}

/* get_float(f) --------------------------------------------------------
	This routine reads the next token from the input stream, and
	converts it to a floating point value in f.  The value returned 
	by next_token is returned as the value of this routine as well.
	The token should be an ascii-coded floating point value.
*/
get_float(f)
	float *f;	/* return variable for floating point value */
{
	int n;		/* holds return value of next_token */
	char t[80];	/* holds token before conversion */
	double atof();

	n = next_token(t);
	*f = atof(t);
	return(n);
}

/* get_double(d) -------------------------------------------------------
	This routine reads the next token from the input stream, and
	converts it to a double floating point value in f.  The value 
	returned by next_token is returned as the value of this routine 
	as well.  The token should be an ascii-coded floating point 
	value.
*/
get_double(d)
	double *d;	/* return variable for floating point value */
{
	int n;		/* holds return value of next_token */
	char t[80];	/* holds token before conversion */
	double atof();

	n = next_token(t);
	*d = atof(t);
	return(n);
}

/* flush_line () -------------------------------------------------------
	This routine scans through the input file until the end of the
	current line is reached.
*/
flush_line ()
{
	char t[100];

	while (token_separator != '\n')
	    next_token (t);
}

/* next_token(t) -------------------------------------------------------
	This routine reads the next token from the input file pointed to
	by fp, and returns the token in t.  The routine also returns:
		0 = file is at EOF
		1 = token is first token on line
		2 = token is in middle of line
		3 = token is last token on line
		    Note: if the last token before a newline is followed
		    by a separator, the next line is treated as a 
		    continuation line.
*/
next_token(t)
	char *t;
{
	int c;			/* character just read in */
	int token_start = 0;	/* token position indicator */
	char q, *s;

	while ((c = getc(fp)) != EOF) {
	    for (s = ts; *s; s++)
		if (c == *s) {
		    token_separator = c;
		    if (token_start) {
			*t = '\0';
			if (++col > 2)
			    col = 2;
			return(col);
		    }
		    c = ' ';
		    break;
		}
	    switch(c) {
		case ' ':	/* white space characters */
		case '\t':
		    break;
		case '\n':	/* new line token separator */
		    if (token_start) {
			col = 0;
			*t = '\0';
			token_separator = c;
			return(3);
		    }
		    break;
		default:	/* normal characters */
		    *t++ = (toupper_sw) ? toupper(c) : c ;
		    token_start = 1;
		    if ((c == '\'') || (c == '\"')) {	/* quote strings */
			q = c;
			while ((c = getc(fp)) != q) {
			    *t++ = c;
			}
			*t++ = c;
		    }
		    break;
	    }  /* switch */
	}  /* while */

	if (token_start) {	/* end of file */
	    *t = '\0';
	    return(3);
	} else
	    return(0);
}
