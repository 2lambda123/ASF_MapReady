#!/usr/bin/perl -w

=head1 NAME

multimatch_dir - create command files and run multimatch on directory contents

=cut

use lib "/asf_tools/perl/lib";

# Compiler pragmas.
use diagnostics;
use strict;

# FIXME: somebody install Params::Validate into the standard repository.
use lib "/home/bkerin/local/lib/site_perl";
# Module pragma used in function parameter checking.
use Params::Validate;

# Standard libraries (they ship with perl).
use File::Basename qw(basename fileparse);
use Getopt::Long;
use Pod::Usage;

my $progname = basename($0);
my $version = '0.2.0';

=head1 SYNOPSIS

B<multimatch_dir> [-t TYPE] input_dir output_dir

=head1 DESCRIPTION

multimatch_dir generates required command files and runs multimatch on
all n choose 2 pairs of image files of a given type found in
input_dir.  Some of the contents of the generated command files
contain hard coded parameters that meet our present (Apr. 18 2002)
needs.  The generated command files and multimatch output go in
output_dir.  Existing files in output_dir are probably clobbered by
newly generated files.

The generated command files use this naming convention:

    match_<file_A_basename>_<file_B_basename>_<common_extension>.cmd

where <file_A_basename> and <file_B_basename> are the base names of
the matched pair, and <common_extension> is the characteristic
extension that was common to both.

The generated output files use the same convention as the command
files, except the extension used is '.out'.

=head1 OPTIONS

The available options are:

=over 4

=item B<-?, --help>

Print help.

=item B<-t TYPE, --type=TYPE>

The type of input files to be processed.  TYPE can be one of the following:

=over 4

=item B<airsar>

JPL airsar processor products.  It is expected that an equal number of
backscatter images (having dot extensions beginning with 'vv',
e.g. '.vvi2') and dem images (having dot extensions beginning with
'dem', e.g. '.demi2') exist in the input directory.  Command files
will be generated and matching performed for all pairs of '.dem' file
and for all pairs of '.vv' files.

=item B<img>

ASF '.img' products.  It is expected than an equal number of '.img'
and '.hdr' files with corresponding base names exist in the input
directory.  Command files will be generated and matching performed for
all pairs of '.img' and '.hdr' pairs.

=back

If this option is omitted, a guess is made based on the files seen in
the directory and a fatal error occurs if more than one type appears
to be present.

=item B<-v, --verbose>

Enable verbose operation.

=item B<--version>

Print version of program.

=back

=cut

# Command line parameters.  See embedded documentation for meanings.
my %p = (
	 # Options.
	 'help' => undef,
	 'type' => undef,
	 'verbose' => undef,
	 'version' => undef,
	 # Arguments.
	 'input_dir' => undef,
	 'output_dir' => undef
	 );

# Process options.
GetOptions(\%p, 'help|?', 'type|t=s', 'verbose|v', 'version') 
    or pod2usage("$progname: option parse failed.\n");
if ( $p{help} ) {
    pod2usage('-exitval' => 0);
}
if ( $p{version} ) {
    print <<END_VERSION_TEXT;
$progname version $version
END_VERSION_TEXT
    exit(0);
}

# Parse command line arguments.
unless ( @ARGV == 2 ) { 
    pod2usage("$progname: wrong number of arguments\n");
}
$p{input_dir} = shift(@ARGV);
$p{output_dir} = shift(@ARGV);

# Sanity check arguments.
unless ( -d $p{input_dir} and -r $p{input_dir} ) {
    die "$p{input_dir} doesn't exist or isn't readable";
}
unless ( -d $p{output_dir} and -w $p{output_dir} ) {
    die "$p{output_dir} doesn't exist or isn't writable";
}

# Print arguments iff verbose mode is enabled.
sub babble { print @_ if $p{verbose}; }

print STDERR "$progname: warning: the return value of the multimatch program itself appears unusable and so is not checked.  When something breaks, the multimatch invocation would be a good place to look...";

# File type to act on. Determined from corresponding command line
# option or by looking at files in the directory.
my $file_type;
if ( defined($p{type}) ) {
    $file_type = $p{type};
} else {
    if ( glob("$p{input_dir}/*.vv*") and !glob("$p{input_dir}/*.img") ) {
	$file_type = "airsar";
    } elsif ( !glob("$p{input_dir}/*.vv*") and glob("$p{input_dir}/*.img") ) {
	$file_type = "img";
    } else {
	die "could not automaticly determine file type to act on.  Maybe try again with -t option?"; 
    }
}

if ( $file_type eq "airsar" ) {

    my @vv_files = glob("$p{input_dir}/*.vv*"); # List of all vv files.

    # Extension of vv files in input directory (dot not included).
    my $vv_extension = (fileparse($vv_files[0], ('(?<=\.)vv.*')))[2];
    
    # All vv files must have the same extension.
    foreach my $file ( @vv_files ) {
	unless ( (fileparse($file, ('(?<=\.)vv.*')))[2] eq $vv_extension ) {
	    die "files with different extensions matching /\.vv.*/ found in $p{input_dir}, don't know how to deal with that";
	}
    }
    
    my @dem_files = glob("$p{input_dir}/*.dem*"); # List of all dem files.

    # Extension of vv files in input directory (dot not included).
    my $dem_extension = (fileparse($dem_files[0], ('(?<=\.)dem.*')))[2];

    # All dem files must have the same extension.
    foreach my $file ( @dem_files ) {
	unless ( (fileparse($file, ('(?<=\.)dem.*')))[2] eq $dem_extension ) {
	    die "files with different extensions matching /\.dem*/' found in $p{input_dir}, don't know how to deal with that";
	}
    }

    my $file_count;		# Number of files of each type (vv and dem).
    # There must be the same number of vv and dem files.
    unless ( ($file_count = @vv_files) == @dem_files ) {
	die "found different numers of dem files (files with extensions like '.dem*') and vv files (files with extensions like '.dem*'), don't know how to handle that";
    }

    # Generate command files for vv files.
    for ( my $i = 0 ; $i < @vv_files - 1 ; $i++ ) {
	for ( my $i2 = $i + 1 ; $i2 < @vv_files ; $i2++ ) {
	    my $file_a_basename = basename($vv_files[$i], (".$vv_extension"));
	    my $file_b_basename = basename($vv_files[$i2], (".$vv_extension"));
	    # Base name of generated command files and output files.
	    my $output_basename = "match_${file_a_basename}_${file_b_basename}_${vv_extension}";
	    my $com_file = "$p{output_dir}/$output_basename.cmd";
	    &babble("Creating command file $com_file ...\n");
	    open(COM_FILE, ">$com_file") 
		or die "couldn't open $com_file for writing";
	    print COM_FILE <<END_COMMAND_FILE
$p{output_dir}/$output_basename.out
rwsize=128
skipxy=100,100
srchxy=32,32
meanxy=0,0
setnum=1

mgh=$vv_files[$i],$dem_files[$i]
mgh=$vv_files[$i2],$dem_files[$i2]
END_COMMAND_FILE
            ;
	    close(COM_FILE) or die "couldn't close $com_file";
	}
    }

    # Generate command files for dem files.
    for ( my $i = 0 ; $i < @dem_files - 1 ; $i++ ) {
	for ( my $i2 = $i + 1 ; $i2 < @dem_files ; $i2++ ) {
	    my $file_a_basename = basename($dem_files[$i], 
					   (".$dem_extension"));
	    my $file_b_basename = basename($dem_files[$i2], 
					   (".$dem_extension"));
	    # Base name of generated command files and output files.
	    my $output_basename = "match_${file_a_basename}_${file_b_basename}_${dem_extension}";
	    my $com_file = "$p{output_dir}/$output_basename.cmd";
	    &babble("Creating command file $com_file ...\n");
	    open(COM_FILE, ">$com_file") 
		or die "couldn't open $com_file for writing";
	    print COM_FILE <<END_COMMAND_FILE
$p{output_dir}/$output_basename.out
rwsize=128
skipxy=100,100
srchxy=32,32
meanxy=0,0
setnum=2

mgh=$vv_files[$i],$dem_files[$i]

mgh=$vv_files[$i2],$dem_files[$i2]
END_COMMAND_FILE
        ;
        close(COM_FILE) or die "couldn't close $com_file";
	}
    }

} elsif ( $file_type eq "img") {

    my @img_files = glob("$p{input_dir}/*.img"); # List of all img files.
    my @hdr_files = glob("$p{input_dir}/*.dem*"); # List of all hdr files.

    my $file_count;		# Number of files of each type (img and hdr). 
    # There must be the same number of img and hdr files.
    unless ( ($file_count = @img_files) == @hdr_files ) {
	die "found different numbers of '.img' files and '.hdr' files, don't know how to handle that";
    }

    # Generate command files.
    for ( my $i = 0 ; $i < $file_count - 1 ; $i++ ) {
	for ( my $i2 = $i + 1 ; $i2 < $file_count ; $i2++ ) {
	    my $file_a_basename = basename($img_files[$i], (".img"));
	    my $file_b_basename = basename($img_files[$i2], (".img"));
	    # Base name of generated command files and output files.
	    my $output_basename = "match_${file_a_basename}_${file_b_basename}_img";
	    my $com_file = "$p{output_dir}/$output_basename.cmd";
	    &babble("Creating command file $com_file ...\n");
	    open(COM_FILE, ">$com_file") 
		or die "couldn't open $com_file for writing";
	    print COM_FILE <<END_COMMAND_FILE
$p{output_dir}/$output_basename.out
rwsize=128
skipxy=100,100
srchxy=32,32
meanxy=0,0
setnum=2

dte=$img_files[$i];
hdr=$hdr_files[$i];

dte=$img_files[$i2];
hdr=$hdr_files[$i2];
END_COMMAND_FILE
            ;
	    close(COM_FILE) or die "couldn't close $com_file";
	}
    }

} else {
    die "unknown file type '$file_type'";
}

# Run multimatch on each of the generated command files.
my @cmd_files = glob("$p{output_dir}/*.cmd");
foreach my $file ( @cmd_files ) {
    # We need to echo a newline to multimatch because it mindlessly
    # sometimes requires it to be entered in order to exit.  Why it
    # can't just print a message then exit is beyond me.
    my $shell_command = "echo -n '\n' | multimatch $file";
    # The multimatch program sometimes has a bad return value, so it
    # doesn't get checked.
    system($shell_command);
} 

=head1 AUTHOR

Britton Kerin <bkerin@mail1.asf.alaska.edu>

=cut
